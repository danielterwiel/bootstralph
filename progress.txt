## 2026-01-17: review-001 completed

**Task**: Verify Next.js incompatibility rules are complete
**Check**: Can Next.js actually use React Router? Are there edge cases where TanStack Router works with Next.js?

**Finding**:
- React Router CAN technically be used in Next.js but loses SSR/SEO benefits and is not recommended
- TanStack Router conflicts with Next.js History API - workarounds exist (memory history, route groups, patching) but you lose SSR benefits
- The incompatibility rules in PLAN.md are correct: Next.js should not use TanStack Router or React Router as primary routing

**Action Required**: None - the PLAN.md incompatibility rules are accurate

**Sources**:
- https://github.com/TanStack/router/discussions/346
- https://thenewstack.io/next-js-react-router-tanstack-when-to-use-each/
- https://tanstack.com/start/latest/docs/framework/react/comparison
- https://medium.com/@cubode/client-side-routing-in-nextjs-15-tanstack-router-integration-d2e3ce1c6f56

## 2026-01-17: review-002 completed

**Task**: Verify TanStack Start + RSC compatibility status
**Check**: Is RSC support still 'coming soon' or has it shipped? Check TanStack changelog

**Finding**:
- RSC support is still "coming soon" as of January 2026
- TanStack Start v1 is in Release Candidate stage (feature-complete, API stable)
- Official docs state: "we are actively working on integration and expect to support them in the near future"
- RSC will land as a non-breaking v1.x addition
- TanStack is taking a measured approach to ensure RSC integration aligns with type-safety and flexibility principles
- Server Functions already support returning JSX/elements from createServerFn

**Action Required**: None - the PLAN.md statement "rsc: Not yet supported (coming soon)" is accurate

**Sources**:
- https://tanstack.com/start/latest/docs/framework/react/overview
- https://tanstack.com/blog/announcing-tanstack-start-v1
- https://github.com/TanStack/router/discussions/802
- https://strapi.io/blog/building-better-apps-with-tan-stack-start-and-tanner-linsley

## 2026-01-17: review-003 completed

**Task**: Verify Expo + Vitest incompatibility
**Check**: Is vitest-react-native mature enough now? Check latest status

**Finding**:
- vitest-react-native is NOT production-ready - the package explicitly warns "This package is still WIP"
- Current version is only 0.1.5 with no official releases, only 76 GitHub stars and 5 forks
- Community feedback describes it as "not very reliable" with testing-library functions like `getByTestId` and `getByText`
- Combining React-Native-Testing-Library + React-Native + Expo + Vitest is described as "an endless pit of issues"
- React Native Testing Library maintainers state they "try not to add any code that would force running on Jest" but haven't tested vitest-react-native themselves
- The main Vitest framework is at v4.0.17, but vitest-react-native remains experimental

**Action Required**: None - the PLAN.md incompatibility rules are correct: Jest is required for React Native/Expo, and Vitest should only be used for web projects

**Sources**:
- https://github.com/sheremet-va/vitest-react-native
- https://www.npmjs.com/package/vitest-react-native/v/0.1.5
- https://github.com/callstack/react-native-testing-library/discussions/1142

## 2026-01-17: review-004 completed

**Task**: Verify Uniwind stability
**Check**: Is Uniwind production-ready or still in beta? Check release status

**Finding**:
- Uniwind IS production-ready - official docs explicitly state "Both versions are production-ready and actively maintained"
- Current version is v1.2.4 (released January 13, 2026)
- Repository created July 29, 2025, now has 1.2k GitHub stars and 21 releases
- Offers 2x performance improvement over NativeWind
- HeroUI Native has fully migrated to Uniwind, reporting 250% performance boost
- Both free (MIT license) and Pro ($99/seat/year with C++ engine) versions available
- Built by the creators of Unistyles, a proven React Native styling solution

**Action Required**: None - the PLAN.md recommendation of Uniwind as default mobile styling is appropriate

**Sources**:
- https://github.com/uni-stack/uniwind
- https://uniwind.dev/
- https://docs.uniwind.dev/pro-version
- https://www.reactnativecrossroads.com/posts/introducing-uniwind-the-fastest-tailwind-bindings-for-react-native/

## 2026-01-17: review-005 completed

**Task**: Verify oxfmt alpha stability
**Check**: oxfmt is listed as alpha - is it stable enough for default recommendation?

**Finding**:
- Oxfmt is currently in alpha (announced December 1, 2025) with beta ETA Q1 2026
- Current version is v0.24.0 (January 12, 2026) with active weekly releases
- Passes 95% of Prettier's JavaScript and TypeScript tests
- 30x faster than Prettier, 3x faster than Biome
- Professionally maintained by VoidZero/Oxc team with frequent bug fixes
- SST's opencode has added experimental oxfmt support, indicating real-world adoption
- Will be integrated into Vite+ as `vite fmt` (public preview early 2026)
- For CLI scaffolder targeting developers wanting cutting-edge tools, oxfmt is reasonable default

**Action Required**: Consider adding Prettier as explicit fallback option for users who need 100% stability. Current PLAN.md recommendation is acceptable.

**Sources**:
- https://oxc.rs/blog/2025-12-01-oxfmt-alpha.html
- https://voidzero.dev/posts/announcing-oxfmt-alpha
- https://github.com/oxc-project/oxc/releases
- https://github.com/sst/opencode/pull/5620
- https://voidzero.dev/posts/announcing-vite-plus

## 2026-01-17: review-006 completed

**Task**: Check Universal platform flow logic
**Check**: If user selects Universal, we auto-select Expo + Tamagui. But should we ask about styling?

**Finding**:
- The wizard SHOULD ask about styling for Universal platform, not auto-select Tamagui
- While Tamagui is the best option for true universal apps (75k weekly downloads, optimizing compiler, extracts CSS on web), there are valid alternatives:
  - **NativeWind** (403k weekly downloads) - Familiar Tailwind approach, larger community, compiles utilities ahead of time
  - **Gluestack UI v3** - Combines NativeWind's styling engine with accessible, unstyled components
- Teams already using Tailwind may strongly prefer NativeWind over Tamagui's unique syntax
- Tamagui has a steeper learning curve that may not suit all teams
- Auto-selecting Tamagui ignores these valid use cases

**Action Required**: Update PLAN.md to:
1. For Universal platform, ask styling question with options:
   - Tamagui (Recommended) - Best performance, comprehensive design system
   - NativeWind - Familiar Tailwind approach, larger community
   - Gluestack UI - NativeWind + accessible components
2. Update wizard flow description to show styling is NOT auto-selected for Universal

**Sources**:
- https://blog.logrocket.com/best-react-native-ui-component-libraries/
- https://blog.logrocket.com/unistyles-vs-tamagui-cross-platform-react-native-styles/
- https://tamagui.dev/
- https://www.producthunt.com/products/tamagui/alternatives

## 2026-01-17: review-007 completed

**Task**: Check Astro + Auth flow
**Check**: Astro uses React islands for auth - is the UX clear that auth only works in islands?

**Finding**:
- The premise of this review was INCORRECT - Astro authentication does NOT only work in React islands
- **Clerk** has a native Astro SDK (`@clerk/astro`) with server-side middleware, route protection, and Astro components
- **better-auth** also supports server-side authentication in Astro without requiring React islands
- Both providers use `clerkMiddleware()` / auth middleware for route protection that runs server-side
- React islands are optional - primarily for interactive UI components (login buttons, user menus)
- The PLAN.md line "auth: better-auth, Clerk (via React islands)" was misleading

**Action Required**: Updated PLAN.md Astro section to clarify:
- Changed "auth: better-auth, Clerk (via React islands)" to "auth: better-auth, Clerk (native Astro SDKs with server-side middleware)"
- Updated note to "Use React islands for interactive UI; auth works server-side via middleware"

**Sources**:
- https://docs.astro.build/en/guides/authentication/
- https://clerk.com/docs/quickstarts/astro
- https://dev.to/isnan__h/authenticating-users-in-astro-react-apps-with-better-auth-3loe
- https://www.better-auth.com/docs/reference/resources

## 2026-01-17: review-008 completed

**Task**: Check feature selection order
**Check**: Features are selected before deployment. Should deployment affect available features (e.g., edge functions)?

**Finding**:
- The current flow (features before deployment) is CORRECT
- Edge runtimes have significant limitations that require post-selection validation:
  - **Cloudflare Workers**: V8 isolates, 3MB bundle limit on free plan, TCP connection restrictions
  - **Vercel Edge**: V8 isolates, limited Node.js APIs
  - **Netlify Edge**: Deno-based runtime, different API surface
- ORM compatibility varies by deployment platform:
  - **Prisma**: Requires Prisma Accelerate or Prisma Postgres for edge (bundle too large, TCP issues)
  - **Drizzle**: Edge-compatible but needs specific drivers (@libsql/client for Turso, Neon serverless, PlanetScale serverless)
- Most features work on most platforms, so asking deployment first adds unnecessary cognitive overhead
- Better UX pattern: Let users select features first, then validate against deployment and warn about incompatibilities with suggested alternatives

**Action Required**: Add post-deployment validation step to wizard:
1. Check for edge runtime incompatibilities in src/compatibility/validators.ts
2. When user selects Cloudflare/Vercel Edge/Netlify Edge AND Prisma, warn that Prisma Accelerate is required OR suggest Drizzle with edge-compatible driver
3. Added "Edge Runtime Compatibility" section to PLAN.md with detailed ORM compatibility matrix

**Sources**:
- https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview
- https://orm.drizzle.team/docs/tutorials/drizzle-with-vercel-edge-functions
- https://github.com/drizzle-team/drizzle-orm/discussions/3146
- https://dev.to/dataformathub/cloudflare-vs-vercel-vs-netlify-the-truth-about-edge-performance-2026-50h0
- https://github.com/t3-oss/create-t3-app/issues/1452

## 2026-01-17: review-009 completed

**Task**: Check mobile E2E testing in recommended toolset
**Check**: Recommended toolset says 'Playwright/Maestro' but should show only Maestro for mobile

**Finding**:
- The PLAN.md is ALREADY CORRECT - E2E testing recommendations are clearly platform-specific
- Key Decisions table shows "Playwright (web), Maestro (mobile)" with explicit platform separation
- E2E Testing Compatibility matrix (lines 214-219) shows:
  - Playwright: ✅ Web, ❌ Expo, ❌ React Native
  - Maestro: ❌ Web, ✅ Expo, ✅ React Native
- Expo section (line 111) shows "Jest (unit), Maestro (e2e, recommended), Detox" - only mobile tools
- Incompatibility Rules explicitly state "Expo | Playwright/Cypress | Use Maestro/Detox instead"
- There is no combined "Playwright/Maestro" recommendation - the review task premise was incorrect

**Action Required**: None - the PLAN.md already correctly separates E2E testing recommendations by platform

**Sources**:
- PLAN.md lines 214-219 (E2E Testing Compatibility matrix)
- PLAN.md line 49 (Incompatibility Rules)
- PLAN.md line 111 (Expo testing recommendations)
- PLAN.md line 375 (Key Decisions Summary)

## 2026-01-17: review-010 completed

**Task**: Check Biome mutual exclusivity logic
**Check**: If Biome selected for linting, formatting question should be skipped. Is this clear in the flow?

**Finding**:
- The PLAN.md incompatibility rules correctly state "Biome | ESLint + Prettier | Pick one linting approach"
- The Linting/Formatting Compatibility table shows Biome is "Lint + Format" (all-in-one)
- However, there was NO explicit wizard flow documentation stating that selecting Biome should skip the formatting question
- Biome v2.x is now stable and production-ready (2025), offering 10-25x speed over ESLint+Prettier
- Biome has 97% Prettier compatibility and 200+ linting rules
- Single binary replaces 127+ npm packages (eslint, prettier, eslint-config-prettier, eslint-plugin-prettier, etc.)

**Action Required**: Added "Wizard Flow Logic: Linting & Formatting" section to PLAN.md documenting:
1. If user selects Biome for linting → skip formatting question (Biome handles both)
2. If user selects oxlint → show formatting question with oxfmt/Prettier options
3. If user selects ESLint → show formatting question with Prettier/oxfmt options
4. Implementation note: Logic goes in src/compatibility/filters.ts and src/prompts/tooling.ts

**Sources**:
- https://biomejs.dev/guides/migrate-eslint-prettier/
- https://medium.com/@pouria.r.1990/biome-js-the-unified-linter-and-formatter-replacing-eslint-and-prettier-2a752d8f357c
- https://betterstack.com/community/guides/scaling-nodejs/biome-eslint/
- https://dev.to/saswatapal/why-i-chose-biome-over-eslintprettier-20x-faster-linting-one-tool-to-rule-them-all-10kf

## 2026-01-17: review-011 completed

**Task**: Verify create-start CLI exists
**Check**: Plan says 'Wrap create-start' but TanStack Start CLI might have different name

**Finding**:
- The TanStack Start CLI EXISTS and is actively maintained
- Official package: `@tanstack/create-start` (v0.47.0 as of January 2026)
- Invocation: `npm create @tanstack/start@latest` or `pnpm create @tanstack/start@latest`
- Creates Vite-based applications with TanStack Router
- Supports multiple package managers: npm, yarn, pnpm, bun, deno
- Toolchain options: Biome or ESLint/Prettier
- Add-ons support: shadcn, tanstack-query, etc.
- MCP support for AI-assisted development
- The PLAN.md reference to 'create-start' was a shorthand - clarified to use actual npm create syntax

**Action Required**: Updated PLAN.md scaffolding table to clarify the exact command

**Sources**:
- https://www.npmjs.com/package/@tanstack/create-start
- https://tanstack.com/start/latest/docs/framework/react/quick-start
- https://github.com/TanStack/create-tsrouter-app/blob/main/cli/create-start-app/README.md

## 2026-01-17: review-012 completed

**Task**: Verify Remix scaffolder approach
**Check**: Should we use create-remix or React Router v7's scaffolder? They've merged

**Finding**:
- Remix has been MERGED into React Router v7 (announced December 2024, released December 2024)
- The official scaffolder is now `create-react-router` (v7.12.0 as of January 2026)
- Invocation: `npx create-react-router@latest my-app`
- React Router v7's "framework mode" includes all Remix features: loaders, actions, server rendering
- The `create-remix` package should NOT be used for new projects
- React Router v7 IS the successor to Remix v2 - same team, same philosophy
- Templates available via `--template remix-run/react-router-templates/<name>`
- Remix v3 exists as a separate React-less rewrite (Preact fork) but has no official docs and is not recommended

**Action Required**: Updated PLAN.md:
1. Changed scaffolding table from 'Wrap `create-remix`' to 'Wrap `create-react-router` (`npx create-react-router@latest`)'
2. Updated section title from 'Remix / React Router v7' to 'React Router v7 - Framework Mode'
3. Updated bundler from 'Vite (via Remix Vite plugin)' to 'Vite (built-in)'
4. Updated web frameworks references from 'Remix' to 'React Router v7'

**Sources**:
- https://reactrouter.com/upgrading/remix
- https://remix.run/blog/react-router-v7
- https://remix.run/blog/merging-remix-and-react-router
- https://www.npmjs.com/package/create-react-router
- https://reactrouter.com/start/framework/installation
- https://developers.cloudflare.com/workers/framework-guides/web-apps/react-router/

## 2026-01-17: review-013 completed

**Task**: Verify Astro scaffolder integration
**Check**: Does create astro support all the integrations we want to offer?

**Finding**:
- `create astro` (invoked via `npm create astro@latest`) DOES support all integrations we want to offer
- **Official integrations via `astro add`**:
  - UI frameworks: @astrojs/react, @astrojs/vue, @astrojs/svelte, @astrojs/solid-js, @astrojs/preact, @astrojs/alpinejs
  - Adapters: @astrojs/vercel, @astrojs/netlify, @astrojs/cloudflare, @astrojs/node
  - Other: @astrojs/db, @astrojs/mdx, @astrojs/markdoc, @astrojs/sitemap, @astrojs/partytown
- **Tailwind CSS**: Astro 5.2+ supports `astro add tailwind` which installs @tailwindcss/vite plugin for Tailwind v4 (the old @astrojs/tailwind is deprecated)
- **Auth providers**: Clerk (@clerk/astro) and better-auth require manual npm install but have full native Astro support with server-side middleware
- **ORMs**: Drizzle and Prisma require manual installation but work fully in Astro API routes
- **The `--add` flag** allows adding multiple integrations during creation: `npm create astro@latest -- --add react --add tailwind`
- All PLAN.md Astro requirements (styling, auth, ORM, deploy, testing) are achievable

**Action Required**: None - the PLAN.md correctly states 'Wrap `create astro`' and all desired integrations are supported

**Sources**:
- https://docs.astro.build/en/install-and-setup/
- https://docs.astro.build/en/guides/integrations-guide/
- https://docs.astro.build/en/guides/integrations-guide/react/
- https://tailwindcss.com/docs/guides/astro
- https://clerk.com/docs/quickstarts/astro
- https://docs.astro.build/en/guides/authentication/

## 2026-01-17: review-014 completed

**Task**: Verify Claude Code Docker image exists
**Check**: Plan references ghcr.io/anthropics/claude-code:latest - does this image exist?

**Finding**:
- There is NO official `ghcr.io/anthropics/claude-code:latest` Docker image
- Anthropic provides two official methods:
  1. **DevContainer feature**: `ghcr.io/anthropics/devcontainer-features/claude-code:1` for devcontainer.json
  2. **Reference Dockerfile**: In the claude-code repo using `node:20` base + `npm install -g @anthropic-ai/claude-code`
- Docker provides official support via `docker sandbox run claude` command
  - Uses `docker/sandbox-templates:claude-code` image
  - Automatic credential management (API key stored in persistent Docker volume)
  - Includes: Docker CLI, GitHub CLI, Node.js, Go, Python 3, Git, ripgrep, jq
- For bootstralph, three approaches are valid:
  1. **Docker Desktop users**: `docker sandbox run claude` (simplest)
  2. **Custom environments**: Generate Dockerfile using node:20 + npm install
  3. **VS Code users**: Generate devcontainer.json with claude-code feature

**Action Required**: Updated PLAN.md with comprehensive Docker Configuration section documenting all three approaches, including example configurations for each method.

**Sources**:
- https://github.com/anthropics/devcontainer-features
- https://github.com/anthropics/devcontainer-features/blob/main/src/claude-code/README.md
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://github.com/anthropics/claude-code/blob/main/.devcontainer/Dockerfile
- https://code.claude.com/docs/en/devcontainer

## 2026-01-17: review-015 completed

**Task**: Verify Docker compose syntax
**Check**: Is the docker-compose.yml syntax correct? Check volume mounts for API key

**Finding**:
- Docker's official `docker sandbox` approach uses CLI flags (`-e`, `-v`) not docker-compose.yml
- For custom Dockerfile approach, docker-compose.yml should use standard syntax:
  1. **Environment variables** via `environment:` section referencing .env files (`ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}`), never hardcoded
  2. **Volume mounts** with `volumes:` using `host-path:container-path` syntax (e.g., `.:/workspace`, `claude-config:/home/node/.claude`)
  3. **Named volumes** for persistence across container restarts
  4. For enhanced security, Docker secrets can be used
- Credentials persist in `docker-claude-sandbox-data` Docker volume mounted at `/mnt/claude-data`
- The PLAN.md correctly notes docker-compose.yml as a file to generate but lacked a template

**Action Required**: Added docker-compose.yml template to PLAN.md showing correct syntax with:
- Environment variable reference pattern (never hardcoding API keys)
- Volume mounts for workspace and .claude config
- Named volumes for persistence
- Security notes about .env files and Docker secrets

**Sources**:
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://docs.docker.com/ai/sandboxes/advanced-config/
- https://code.claude.com/docs/en/devcontainer
- https://github.com/RchGrav/claudebox
- https://gofranz.com/blog/automate-testing-with-docker-compose-and-claude-code/

## 2026-01-17: review-016 completed

**Task**: Verify network_mode: none security
**Check**: Commented out network isolation - should it be default? How does Ralph work without network?

**Finding**:
- `network_mode: none` is NOT viable for Claude Code
- Claude Code's core architecture requires network connectivity for:
  1. **API Communication**: Every Claude response requires calling `api.anthropic.com` - the AI doesn't run locally
  2. **Package Installation**: `npm install` needs `registry.npmjs.org`
  3. **Git Operations**: Cloning and pushing require `github.com`
- Required minimum domains for whitelisting:
  - `api.anthropic.com` - Core Claude API communication
  - `claude.ai` - Platform services
  - `registry.npmjs.org` - npm package installation
  - `github.com` - Repository access, cloning
- The correct approach is **domain whitelisting** using iptables-based filtering, not full network isolation
- This provides defense-in-depth (prevents data exfiltration to arbitrary servers) while maintaining functionality
- Anthropic's own sandboxing uses a proxy-based approach that restricts domains but doesn't fully isolate network

**Action Required**: Updated PLAN.md with comprehensive "Network Isolation Strategy" section including:
- Explanation of why `network_mode: none` doesn't work
- Required domains table
- iptables-based firewall script for domain whitelisting
- Security trade-offs comparison table
- Recommendation for domain whitelisting approach

**Sources**:
- https://code.claude.com/docs/en/sandboxing
- https://www.anthropic.com/engineering/claude-code-sandboxing
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://mfyz.com/ai-coding-agent-sandbox-container/
- https://blog.arcade.dev/using-docker-sandboxes-with-claude-code

## 2026-01-17: review-017 completed

**Task**: Verify openskills programmatic API
**Check**: Plan uses execSync for openskills - is there a proper Node.js API?

**Finding**:
- openskills (v1.3.2 by numman-ali) is **CLI-only with NO programmatic Node.js API**
- The package.json has `main: './dist/cli.js'` with no `exports` field - it's designed as a command-line tool, not a library
- AI agents invoke it via shell commands (`openskills install`, `openskills sync`) rather than JavaScript imports
- This is the intended usage pattern - openskills treats skills as static markdown files and uses CLI invocation for universal compatibility across Claude Code, Cursor, Windsurf, Aider, and other AI agents
- OpenSkills uses a CLI-based approach rather than MCP to enable universal compatibility with any AI agent that has shell access
- The correct approach for bootstralph is using `execa` to spawn openskills CLI commands

**Action Required**: Updated PLAN.md Tech Stack section to clarify openskills is CLI-only (via execa), not a programmatic API. The implementation in src/ralph/skills.ts should use execa to run openskills commands.

**Sources**:
- https://github.com/numman-ali/openskills
- https://www.npmjs.com/package/openskills
- https://deepwiki.com/numman-ali/openskills/2-getting-started
- https://github.com/numman-ali/openskills/blob/main/package.json

## 2026-01-17: review-018 completed

**Task**: Verify all skill names are correct
**Check**: Check that skill names like 'supabase-operations' exist in marketplaces

**Finding**:
Most skill names in PLAN.md are correct but several needed corrections:

**VERIFIED EXISTING:**
- `planning-with-files` - ✅ EXISTS (OthmanAdi/planning-with-files)
- `react-best-practices` - ✅ EXISTS (vercel-labs/agent-skills)
- `vercel-deploy-claimable` - ✅ EXISTS (vercel-labs/agent-skills)
- `web-design-guidelines` - ✅ EXISTS (vercel-labs/agent-skills)
- `expo-app-design` - ✅ EXISTS (expo/skills)
- `expo-deployment` - ✅ EXISTS (expo/skills)
- `upgrading-expo` - ✅ EXISTS (expo/skills)
- `supabase-operations` - ✅ EXISTS (FastMCP marketplace)
- `better-auth` - ✅ EXISTS (@Microck/ordinary-claude-skills)
- `clerk-pack` - ✅ EXISTS (24 skills from claude-code-plugins-plus)
- `webapp-testing` - ✅ EXISTS (official anthropics/skills)
- `tailwind-v4-shadcn` - ✅ EXISTS (multiple sources)
- `docker-containerization` - ✅ EXISTS (multiple sources)
- `turborepo` - ✅ EXISTS (multiple sources)
- `monorepo-management` - ✅ EXISTS (wshobson/agents-plugins)
- Trail of Bits skills - ✅ EXISTS (trailofbits/skills: building-secure-contracts, burpsuite-project-parser)
- Drizzle skills - ✅ EXISTS (drizzle-orm-d1, drizzle, drizzle-migration)

**NOT FOUND / INCORRECT:**
- `superpowers` - NOT a skill name, it's the repo name (obra/superpowers). Actual skills are: test-driven-development, systematic-debugging, verification-before-completion, brainstorming, writing-plans, executing-plans, etc.
- `supabase-platform-specialist` - ❌ DOES NOT EXIST
- `stripe-integration` - ❌ NOT FOUND as specific skill
- `stripe-best-practices` - ❌ NOT FOUND as specific skill
- `vitest-testing-expert` - ❌ NOT FOUND (use `webapp-testing` instead)

**Action Required**: Updated PLAN.md Skills Installation Strategy table with corrected skill names and sources.

**Sources**:
- https://github.com/vercel-labs/agent-skills
- https://github.com/obra/superpowers
- https://github.com/expo/skills
- https://github.com/anthropics/skills/tree/main/skills
- https://github.com/OthmanAdi/planning-with-files
- https://fastmcp.me/Skills/Details/316/supabase-operations
- https://claudecodeplugins.io/skills/clerk-migration-deep-dive/
- https://claude-plugins.dev/skills/@Microck/ordinary-claude-skills/better-auth
- https://claude-plugins.dev/skills/@ovachiever/droid-tings/tailwind-v4-shadcn
- https://claude-plugins.dev/skills/@ailabs-393/ai-labs-claude-skills/docker-containerization
- https://claude-plugins.dev/skills/@timelessco/recollect/turborepo
- https://skillsmp.com/skills/wshobson-agents-plugins-developer-essentials-skills-monorepo-management-skill-md
- https://github.com/trailofbits/skills
- https://claude-plugins.dev/skills/@jezweb/claude-skills/drizzle-orm-d1

## 2026-01-17: review-019 completed

**Task**: Verify Drizzle patterns skill exists
**Check**: Plan says 'Drizzle patterns (community)' - is there an actual skill?

**Finding**:
YES, multiple Drizzle skills exist and are actively maintained:

1. **drizzle-orm-d1** (@jezweb/claude-skills)
   - Status: Production Ready, last updated January 9, 2026
   - Covers D1 database patterns including batch API for transactions, migrations, 12 common D1 errors
   - Package versions: drizzle-orm@0.45.1, drizzle-kit@0.31.8

2. **drizzle** (@korallis/Droidz)
   - General Drizzle ORM skill for schema definition, migrations, type-safe queries
   - Activates when users discuss Drizzle ORM, database schemas, or SQL queries

3. **drizzle-migration** (@Dexploarer/hyper-forge)
   - Guides proper migration workflow using Drizzle Kit
   - Covers schema modification, migration generation, rollback strategies
   - Emphasizes inspecting generated SQL before running db:migrate

4. **rr-drizzle** (@roderik/ai-rules)
   - Additional Drizzle patterns from ai-rules collection

The PLAN.md already correctly lists these as `drizzle-orm-d1, drizzle, drizzle-migration` (line 282).
This was also verified during review-018.

**Action Required**: None - the PLAN.md Skills Installation Strategy is already accurate

**Sources**:
- https://claude-plugins.dev/skills/@jezweb/claude-skills/drizzle-orm-d1
- https://claude-plugins.dev/skills/@korallis/Droidz/drizzle
- https://claude-plugins.dev/skills/@Dexploarer/hyper-forge/drizzle-migration
- https://mcpmarket.com/tools/skills/drizzle-orm-development
- https://skillsmp.com/skills/jezweb-claude-skills-skills-drizzle-orm-d1-skill-md

## 2026-01-17: review-020 completed

**Task**: Check SaaS preset completeness
**Check**: SaaS preset uses NativeWind but it's for mobile - should be Tailwind + shadcn

**Finding**:
- The review premise was INCORRECT - the PLAN.md never specified NativeWind for the SaaS preset
- The directory structure showed `saas.ts # Next.js + auth + payments` and all Next.js sections consistently specify `Tailwind + shadcn/ui` as the styling choice (lines 65, 78, 92)
- However, the PLAN.md lacked explicit preset configurations, which could cause confusion
- Verified via industry standards:
  - Vercel's official Next.js SaaS Starter uses Tailwind + shadcn/ui
  - ixartz/SaaS-Boilerplate uses Tailwind + shadcn/ui
  - Encore.ts SaaS Starter uses Tailwind + shadcn/ui
  - All major SaaS starters use Tailwind + shadcn/ui (NOT NativeWind)
- NativeWind is for mobile (Expo/React Native), not web projects

**Action Required**: Added explicit "Preset Configurations" section to PLAN.md documenting full configuration for each preset:
1. **SaaS Preset**: Next.js + Tailwind CSS + shadcn/ui + better-auth + Drizzle + Stripe + Vercel
2. **Mobile Preset**: Expo + Uniwind + Clerk + Supabase + EAS
3. **API Preset**: Hono + Drizzle + better-auth + Cloudflare Workers
4. **Fullstack Preset**: Turborepo + Next.js + Hono + Biome

The SaaS preset now explicitly shows `styling: Tailwind CSS + shadcn/ui` to prevent any future confusion.

**Sources**:
- https://vercel.com/templates/next.js/next-js-saas-starter
- https://github.com/ixartz/SaaS-Boilerplate
- https://encore.dev/templates/saas-starter
- https://www.shadcn.io/template/nextjs-saas-starter
- https://indie-starter.dev/blog/shadcn-templates

## 2026-01-17: review-021 completed

**Task**: Check Mobile preset styling
**Check**: Mobile preset uses NativeWind but Uniwind is now recommended

**Finding**:
- The review premise was INCORRECT - the PLAN.md already correctly specifies Uniwind as the recommended default for Mobile styling
- Verified in multiple locations:
  1. **Mobile Preset section** (line 407): `styling: Uniwind (recommended)`
  2. **Expo section** (line 106): `styling: Uniwind (recommended), NativeWind, Tamagui, Unistyles, StyleSheets`
  3. **React Native CLI section** (line 118): `styling: Uniwind (recommended), NativeWind, Tamagui, StyleSheets`
  4. **Key Decisions Summary** (line 460): `Mobile styling (default) | Uniwind | Fastest Tailwind for RN, from Unistyles creators`
- Uniwind (v1.2.4, January 2026) is production-ready and claims 2.5x faster performance than NativeWind
- Uniwind is a drop-in replacement for NativeWind with near-100% Tailwind compatibility
- NativeWind remains available as an alternative for teams already using it or preferring its larger ecosystem (gluestack UI, NativeWindUI)
- HeroUI Native has migrated to Uniwind, confirming production readiness

**Action Required**: None - the PLAN.md already correctly specifies Uniwind as the recommended Mobile styling default

**Sources**:
- https://uniwind.dev/
- https://www.reactnativecrossroads.com/posts/introducing-uniwind-the-fastest-tailwind-bindings-for-react-native/
- https://nativelaunch.dev/articles/uniwind
- https://github.com/efstathiosntonas/react-native-style-libraries-benchmark
- https://blog.logrocket.com/best-react-native-ui-component-libraries/

## 2026-01-17: review-022 completed

**Task**: Check Monorepo preset package manager
**Check**: Monorepo preset uses pnpm workspaces but bun is default - inconsistent?

**Finding**:
- The review premise was INCORRECT - the PLAN.md did NOT specify pnpm workspaces for the Monorepo preset
- The Fullstack/Monorepo Preset only specified `structure: Turborepo` without mentioning a specific package manager
- The Key Decisions Summary correctly states `bun` as the default package manager
- As of December 2025, Turborepo 2.6 moved Bun package manager support from beta to **STABLE**
- Turborepo 2.5 (October 2025) added Bun pruning support
- Bun workspaces work well with Turborepo using `workspaces: ["apps/*", "packages/*"]` in package.json
- Configuration requires `"packageManager": "bun@1.x.x"` in root package.json
- Key caveat: Use `--cwd` flag for workspace-specific installs (`bun add <pkg> --cwd apps/web`) instead of `--filter`
- Bun is approximately 4x faster than pnpm for clean installs in monorepos
- The PLAN.md is CONSISTENT - bun should be used for Turborepo monorepos

**Action Required**: Added explicit package manager specification (`package_manager: bun (with bun workspaces)`) to Fullstack/Monorepo Preset section. Added "Monorepo Package Manager Notes" subsection with usage details.

**Sources**:
- https://turborepo.dev/blog/turbo-2-6
- https://github.com/vercel/turborepo/discussions/7456
- https://www.fgbyte.com/blog/02-bun-turborepo-hell
- https://github.com/shadcn-ui/ui/discussions/6465
- https://dev.to/kirteshbansal/choosing-the-right-javascript-package-manager-in-2025-npm-vs-yarn-vs-pnpm-vs-bun-2jie
- https://betterstack.com/community/guides/scaling-nodejs/pnpm-vs-bun-install-vs-yarn/

## 2026-01-17: review-023 completed

**Task**: Verify better-auth Expo support
**Check**: Plan shows better-auth as API-only for Expo - is this the best approach?

**Finding**:
- The PLAN.md characterization of better-auth as "API only" for Expo was **INCORRECT**
- better-auth has an official `@better-auth/expo` package (v1.4.10) that provides full native mobile support:
  - **Native session management** via `expo-secure-store` (eliminates loading spinners on app reload)
  - **Deep linking integration** for OAuth flows with automatic scheme conversion
  - **Social auth** with native OAuth flows (Google, Apple, Facebook with ID token verification)
  - **useSession hook** with SecureStore caching for persistent sessions
  - Supports both Expo native and web apps
- Expo's official documentation lists better-auth among recommended authentication services alongside Clerk and Supabase
- TurboStarter offers an official "Expo + better-auth Mobile App Template" demonstrating production usage
- Both better-auth and Clerk now offer **equivalent native SDK support** for Expo

**Action Required**: Updated PLAN.md:
1. Changed Expo auth line from `Clerk (native support), better-auth (API)` to `Clerk (native SDK), better-auth (native SDK via @better-auth/expo)`
2. Updated Auth Provider Compatibility table to show better-auth as "Native" for both Expo and React Native columns

**Sources**:
- https://www.better-auth.com/docs/integrations/expo
- https://www.npmjs.com/package/@better-auth/expo
- https://docs.expo.dev/develop/authentication/
- https://www.turbostarter.dev/stacks/expo-better-auth-mobile-app-template
- https://labs.convex.dev/better-auth/framework-guides/expo

## 2026-01-17: review-024 completed

**Task**: Verify Supabase Auth as option
**Check**: Supabase Auth is in compatibility table but not in wizard options

**Finding**:
- The review premise was CORRECT - Supabase Auth was in the Auth Provider Compatibility table but NOT listed in the framework-specific wizard options
- Supabase Auth is a fully production-ready authentication solution:
  - **Next.js**: `@supabase/ssr` package provides SSR support with App Router, middleware integration, and cookie-based sessions
  - **TanStack Start**: Official quickstart available using supabase-js and @supabase/ssr (TanStack Start still in beta, integration working but expect changes)
  - **React Native/Expo**: Native support via `@supabase/supabase-js` with `@react-native-async-storage/async-storage` for session persistence
  - **Astro**: Works with API routes and server endpoints
- Supabase Auth offers the most generous free tier: 50,000 MAU compared to 10,000 MAU from competitors
- Row Level Security (RLS) integration provides database-level authorization impossible with other solutions
- Note: `@supabase/auth-helpers` package is deprecated - use `@supabase/ssr` instead

**Action Required**: Updated PLAN.md to add Supabase Auth to wizard options:
1. Next.js: `auth: better-auth, Clerk, Supabase Auth`
2. TanStack Start: `auth: better-auth, Clerk, Supabase Auth`
3. React Router v7: `auth: better-auth, Clerk, Supabase Auth`
4. Expo: `auth: Clerk (native SDK), better-auth (native SDK via @better-auth/expo), Supabase Auth (native via @supabase/supabase-js)`
5. React Native CLI: `auth: Clerk, better-auth, Supabase Auth`
6. Astro: `auth: better-auth, Clerk, Supabase Auth`

**Sources**:
- https://supabase.com/docs/guides/auth/quickstarts/react-native
- https://supabase.com/docs/guides/auth/quickstarts/nextjs
- https://supabase.com/docs/guides/auth/server-side/nextjs
- https://supabase.com/docs/guides/getting-started/quickstarts/tanstack
- https://tanstack.com/start/latest/docs/framework/react/examples/start-supabase-basic
- https://docs.expo.dev/guides/using-supabase/

## 2026-01-17: review-025 completed

**Task**: Verify Convex compatibility with all frameworks
**Check**: Convex is listed for Expo backend but is it compatible with Next.js/TanStack?

**Finding**:
Convex is compatible with ALL frameworks mentioned in PLAN.md, not just Expo:

1. **Next.js**: Full App Router support with server rendering (beta) via `convex/nextjs` helpers
   - `preloadQuery` for SSR with client-side reactivity
   - `fetchQuery`, `fetchMutation`, `fetchAction` for Server Components/Actions
   - Official demo app and quickstart available

2. **TanStack Start**: First-class integration via `@convex-dev/react-query`
   - Uses `@tanstack/react-router-with-query` for SSR
   - Live updates from Convex supercharge React Query
   - Hydrating Query Client makes SSR seamless
   - Official example: TanStack Start + Convex Trellaux

3. **React Router v7**: Works with standard Convex React client
   - Same React patterns, useQuery hook works as expected
   - React Router v7 is standard React so Convex React client is compatible

4. **Expo/React Native**: Official support, same React client as web
   - Official quickstart at docs.convex.dev/quickstart/react-native
   - Convex Auth (beta) supports both web and React Native
   - Universal apps possible with Expo + Tamagui + Convex

5. **Astro**: Official starter template available
   - Uses `withConvexProvider` wrapper for React islands
   - `useQuery` and Convex hooks work in client components as usual

The PLAN.md only listed Convex under Expo backend options, but it should be a backend option for ALL frameworks.

**Action Required**: Updated PLAN.md:
1. Added `backend: Convex (real-time), Supabase` to Next.js, TanStack Start, React Router v7, and Astro sections
2. Added notes explaining Convex integration specifics for each framework
3. Expanded Database/Backend Options table with "Reactive queries + type-safety" and "Full-stack type-safe backend" use cases
4. Added "Convex Framework Compatibility" section documenting support for each framework
5. Added `convex` skill to Skills by Stack table

**Sources**:
- https://docs.convex.dev/client/nextjs/app-router/
- https://docs.convex.dev/quickstart/nextjs
- https://docs.convex.dev/client/tanstack/tanstack-start/
- https://docs.convex.dev/quickstart/tanstack-start
- https://tanstack.com/start/latest/docs/framework/react/examples/start-convex-trellaux
- https://docs.convex.dev/quickstart/react-native
- https://docs.convex.dev/client/react-native
- https://www.convex.dev/can-do/mobile-apps
- https://www.convex.dev/templates/astro
- https://www.bitdoze.com/astro-convex-realtime-app/
- https://claude-plugins.dev/skills/@ThijmenGThN/next-leaflet/convex

## 2026-01-17: review-026 completed

**Task**: Verify Firebase option completeness
**Check**: Firebase is listed but no skills mentioned for it

**Finding**:
- Firebase IS listed in PLAN.md as a backend option for Expo (line 116) and in Database/Backend Options table as "NoSQL / Firebase-like"
- However, NO Firebase skill was listed in the Skills by Stack table
- Research found available Firebase-related tools:
  1. **firebase-functions-templates** skill EXISTS (@onesmartguy/next-level-real-estate)
     - Creates production-ready Firebase Cloud Functions with TypeScript
     - Includes Express integration, HTTP endpoints, background triggers, scheduled functions
     - Provides service layer patterns for Firestore operations
  2. **firebase-mcp** (gannonh/firebase-mcp) - MCP server (NOT a skill)
     - Supports Firestore operations (add, list, get, update, delete documents)
     - Storage file management (list, upload, retrieve URLs)
     - Authentication user lookup by ID or email
     - Installed via `npx @gannonh/firebase-mcp`
  3. NO comprehensive Firebase skill exists for general Firebase development patterns (Auth flows, Firestore security rules, real-time listeners)
- The official Claude plugins marketplace shows firebase/firebase-tools with 4,303 stars as "Official Claude plugin for Firebase"

**Action Required**: Updated PLAN.md:
1. Added Firebase row to Skills by Stack table with `firebase-functions-templates` skill
2. Added note that comprehensive Firebase skills are limited - recommend using `firebase-mcp` MCP server for Firestore/Auth operations

**Sources**:
- https://claude-plugins.dev/skills/@onesmartguy/next-level-real-estate/firebase-functions-templates
- https://github.com/gannonh/firebase-mcp
- https://claudemarketplaces.com/plugins/firebase-firebase-tools
- https://github.com/markhilton/mcp-firestore-server

## 2026-01-17: review-027 completed

**Task**: Verify EAS auto-selection
**Check**: Plan auto-selects EAS for Expo - should users have other options?

**Finding**:
YES, users should have other Expo deployment options beyond auto-selecting EAS. Valid alternatives exist:

1. **EAS Build (Cloud)** - Recommended default, no local Xcode/Android Studio required, automatic credential management
2. **Local Builds (`eas build --local`)** - Unlimited free builds using your own hardware, faster iteration, full control
3. **GitHub Actions + Fastlane** - Self-hosted CI/CD pipeline, can save $100s/month vs EAS paid tiers, full control over infrastructure
4. **Codemagic** - Third-party cloud CI/CD with pay-as-you-go pricing, CodePush support at $99/month per 100k MAU

Auto-selecting EAS ignores important use cases:
- **Cost concerns**: EAS free tier has limits (shared queue, monthly build caps), paid tiers start at $19/month
- **Company policies**: Some organizations restrict third-party CI/CD services
- **Self-hosted preference**: Teams wanting full control and reproducible builds
- **Local iteration**: `eas build --local` enables faster debugging without queue wait times

EAS Build should remain the recommended default (easiest path, great for most users) but alternatives should be offered in the wizard.

**Action Required**: Updated PLAN.md:
1. Changed Expo deploy line from `EAS (Expo Application Services)` to `EAS Build (recommended), Local Builds (eas build --local), GitHub Actions + Fastlane, Codemagic`
2. Added "Expo Deployment Options" subsection explaining each option
3. Updated Mobile Preset deploy line to show both cloud and local options

**Sources**:
- https://docs.expo.dev/build-reference/local-builds/
- https://docs.expo.dev/build/introduction/
- https://expo.dev/pricing
- https://github.com/TanayK07/expo-react-native-cicd
- https://docs.codemagic.io/yaml-quick-start/building-a-react-native-app/
- https://blog.logrocket.com/fastlane-build-test-ship-react-native-apps/
- https://iamkhushbajwa.medium.com/releasing-apps-without-expos-eas-builds-5017f304b6be

## 2026-01-17: review-028 completed

**Task**: Verify Railway compatibility
**Check**: Railway is listed for Next.js but not for TanStack Start in detailed section

**Finding**:
- The review premise was INCORRECT - Railway IS already listed for TanStack Start in PLAN.md
- Line 87 already shows: `deploy: Any (Vercel, Cloudflare, Fly.io, Railway)`
- Official TanStack Start documentation explicitly lists Railway as a supported deployment target under the Node.js category
- Railway has multiple community-created templates for TanStack Start:
  1. **TanStack Start Monorepo (Bun)** - Created Dec 2025, 100% success rate, includes Better Auth + Drizzle + Supabase
  2. **TanStack Start - Drizzle** - Created Mar 2025, simple starter with TanStack Query
  3. **TanStack Shopify App Template** - Created Nov 2025, full Shopify app boilerplate
- TanStack Start uses Nitro as its server runtime which supports the `node-server` preset that works natively with Railway
- **Bun deployment caveat**: When using Bun, users must configure `preset: 'bun'` in app.config.ts (not `node-server`) and start with `bun run .output/server/index.mjs`

**Action Required**: None - the PLAN.md already correctly lists Railway as a deployment option for TanStack Start

**Sources**:
- https://tanstack.com/start/latest/docs/framework/react/guide/hosting
- https://railway.com/deploy/tanstack-start-mon-1
- https://railway.com/deploy/nAdb0P
- https://railway.com/deploy/tanstack-shopify-app-template
- https://station.railway.com/questions/tanstack-start-works-locally-but-not-dep-1b8e915a
- https://nitro.build/deploy

## 2026-01-17: review-029 completed

**Task**: Verify Vitest 4 compatibility
**Check**: Plan uses vitest ^4.0.0 - is v4 released and stable?

**Finding**:
- Vitest 4.0 IS released and production-ready
- Released October 22, 2025, current version v4.0.17 (January 12, 2026)
- Key features in v4.0:
  1. **Browser Mode graduated to stable** - No longer experimental, with separate provider packages for Playwright, WebdriverIO, Preview
  2. **Built-in visual regression testing** - New `toMatchScreenshot` assertion for UI component comparison
  3. **Playwright Traces integration** - Generates browser traces for debugging
  4. **Enhanced Locators** - Adds `frameLocator` API and `length` property on locators
  5. **Improved Debugging** - VSCode extension supports "Debug Test" buttons for browser tests
  6. **New Matchers** - `expect.schemaMatching` for schema validation, `toBeInViewport` for visibility checks
- Maintained by VoidZero (same team behind Vite, oxc, Rolldown)
- Active development: v4.1.0-beta.1 already available (January 14, 2026)
- Breaking changes exist - migration guide available at vitest.dev

**Action Required**: None - the PLAN.md recommendation of Vitest for web unit testing is correct and v4.x is stable for production use

**Sources**:
- https://vitest.dev/blog/vitest-4
- https://voidzero.dev/posts/announcing-vitest-4
- https://github.com/vitest-dev/vitest/releases
- https://www.infoq.com/news/2025/12/vitest-4-browser-mode/

## 2026-01-17: review-030 completed

**Task**: Verify Jest + oxlint combination
**Check**: Does oxlint work well with Jest for React Native projects?

**Finding**:
- YES, oxlint works well with Jest for React Native projects
- Oxlint 1.0 stable (June 2025) includes a **native Jest plugin** with 29 Jest-specific rules built in Rust:
  - Test organization: `consistent-test-it`, `max-nested-describe`, `require-top-level-describe`
  - Assertions: `expect-expect`, `max-expects`, `valid-expect`
  - Test structure: `no-disabled-tests`, `no-focused-tests`, `no-conditional-in-test`
  - And 20+ more rules covering mocking, hooks, matchers, snapshots
- **Enable Jest plugin**: Via `--jest-plugin` CLI flag or `"plugins": ["jest"]` in `.oxlintrc.json`
- **Real-world validation**: OneSignal's `react-native-onesignal` library uses oxlint with Jest configuration in production
- **Performance**: Oxlint is 50-100x faster than ESLint with native Jest rules

**CAVEAT - eslint-plugin-react-native**:
- `eslint-plugin-react-native` is NOT natively supported in oxlint
- Workarounds:
  1. Use experimental `jsPlugins` feature: `"jsPlugins": ["eslint-plugin-react-native"]`
  2. Run both linters: `oxlint && eslint` (recommended) - oxlint handles Jest/TS/React fast, ESLint handles RN-specific rules
- The `eslint-plugin-oxlint` package provides `'flat/jest'` config to disable ESLint rules already covered by oxlint, avoiding duplicate warnings

**Recommended Configuration for React Native + Jest**:
```json
// .oxlintrc.json
{
  "plugins": ["jest", "react", "typescript"],
  "rules": {
    "jest/no-focused-tests": "error",
    "jest/no-disabled-tests": "warn"
  }
}
```

**Action Required**: None - the PLAN.md correctly shows Jest for React Native testing and oxlint as the default linter. The combination works well with the native Jest plugin.

**Sources**:
- https://voidzero.dev/posts/announcing-oxlint-1-stable
- https://oxc.rs/docs/guide/usage/linter/plugins
- https://github.com/OneSignal/react-native-onesignal/blob/main/.oxlintrc.json
- https://github.com/oxc-project/eslint-plugin-oxlint
- https://betterstack.com/community/guides/scaling-nodejs/oxlint-explained/

## 2026-01-17: review-031 completed

**Task**: Verify prek stability and adoption
**Check**: Is prek production-ready? Check v0.2.x stability, adoption by Apache Airflow, FastAPI

**Finding**:
- prek IS production-ready for most use cases
- Current version: v0.2.29 (January 16, 2026)
- **Apache Airflow**: Switched to prek in August 2025 (PR #54726 merged by Jarek Potiuk), now using v0.2.12 in production
- **FastAPI**: Switched in December 2025 (PR #14572 by tiangolo merged December 19, 2025), also rolled out to Typer, SQLModel, and other FastAPI ecosystem projects

**Supported Languages**:
- Python (uses uv for virtualenvs)
- Node.js
- Go
- Rust
- Ruby (uses system Ruby, version managers like rvm/rbenv/mise/asdf)
- Lua (via LuaRocks)
- Docker / Docker Image
- System, Script, Pygrep, Fail

**NOT Supported** (yet):
- Conda, Coursier, Dart, Dotnet, Haskell, Julia, Perl, R, Swift
- Deno (experimental/in progress)

**Missing Subcommands**:
- Only `gc` (garbage collection) is not implemented

**Key Advantages**:
- 10x faster than pre-commit
- Uses only 1/3 of disk space
- Built-in monorepo/workspace support
- Parallel hook execution by priority
- Uses uv for Python virtualenvs (faster installs)
- Fully compatible with existing .pre-commit-config.yaml files
- Single binary with no dependencies (doesn't require Python runtime)

**Action Required**: None - prek is production-ready and actively used by major projects. The PLAN.md should consider prek as a valid pre-commit hook option alongside Lefthook and Husky, especially for projects already using Python-based pre-commit hooks.

**Sources**:
- https://github.com/j178/prek
- https://prek.j178.dev/
- https://prek.j178.dev/languages/
- https://github.com/apache/airflow/pull/54258
- https://lists.apache.org/thread/dzs4s8wr8jd7q5r3lvcov2nhqpgt1031
- https://github.com/fastapi/fastapi/pull/14572
- https://hugovk.dev/blog/2025/ready-prek-go/

## 2026-01-17: review-032 completed

**Task**: Verify prek + bun compatibility
**Check**: Does prek work well with bun as package manager and runtime?

**Finding**:
- Prek does NOT natively support Bun as a package manager or runtime for Node.js hooks
- Prek's Node.js language type uses `npm install .` to install hook dependencies - no bun option exists
- No GitHub issue requesting Bun support was found in the prek repository
- However, this is a **non-issue** for bootstralph projects because:

**Why prek + bun works fine in practice:**
1. **Isolated environments**: prek manages its OWN isolated environments for hooks, completely separate from the project's package manager
2. **No interference**: A project using bun for development doesn't conflict with prek's npm-based hook environments
3. **Standalone binary**: prek is a Rust binary with no JavaScript runtime dependency - it manages Node.js toolchains internally
4. **Supported languages**: prek supports Python, Node.js, Go, Rust, Ruby, Lua, Docker, System, Script, Pygrep, Fail
5. **Deno**: Only experimental/WIP support, no Bun support planned

**How prek handles Node.js hooks:**
- Downloads Node.js toolchain if needed (supports semver ranges like `^18.12` or `lts`)
- Expects `package.json` in hook repo
- Runs `npm install .` to install dependencies
- Executes binaries exposed via package `bin` field

**Action Required**: Added clarifying note to PLAN.md Pre-Commit Hook Compatibility section explaining that prek uses npm for Node.js hook environments regardless of project package manager.

**Sources**:
- https://github.com/j178/prek
- https://prek.j178.dev/languages/
- https://github.com/j178/prek/issues (no bun-related issues found)
- https://hugovk.dev/blog/2025/ready-prek-go/

## 2026-01-17: review-041 completed

**Task**: Verify Lefthook config format for oxlint/oxfmt
**Check**: Is the Lefthook config syntax correct for oxlint and oxfmt commands?

**Finding**:
- The Lefthook configuration syntax for oxlint and oxfmt is straightforward
- PLAN.md lacked concrete configuration examples, which has been addressed
- Verified correct Lefthook YAML syntax for both tools:

**For oxlint:**
- Basic: `run: npx oxlint {staged_files}`
- With auto-fix: `run: npx oxlint --fix {staged_files}` with `stage_fixed: true`
- Glob pattern: `glob: "*.{js,ts,jsx,tsx}"`
- Additional fix options: `--fix-suggestions` (may change behavior), `--fix-dangerously` (aggressive)

**For oxfmt:**
- Basic (writes in place): `run: npx oxfmt {staged_files}`
- CI mode (check only): `run: npx oxfmt --check {staged_files}`
- Default behavior is equivalent to `prettier --write` (formats and writes)

**Key Lefthook Configuration Options:**
- `{staged_files}` - Template for files in staging area (pre-commit hook)
- `{push_files}` - Template for committed but unpushed files (pre-push hook)
- `{all_files}` - Template for all git-tracked files
- `stage_fixed: true` - Automatically `git add` files modified by fix operations
- `glob` - Filter files by pattern (supports multiple patterns as list in v1.10.10+)
- `parallel: true` - Run commands concurrently for speed
- `skip: [merge, rebase]` - Skip hooks during merge/rebase operations
- `root` - Run command in subdirectory (useful for monorepos)

**Example Configuration Added to PLAN.md:**
```yaml
pre-commit:
  parallel: true
  commands:
    oxlint:
      glob: "*.{js,ts,jsx,tsx}"
      run: npx oxlint --fix {staged_files}
      stage_fixed: true
    oxfmt:
      glob: "*.{js,ts,jsx,tsx}"
      run: npx oxfmt {staged_files}
      stage_fixed: true
```

**Action Required**: Added "Lefthook Configuration Examples" subsection to PLAN.md with complete YAML syntax examples.

**Sources**:
- https://lefthook.dev/configuration/
- https://lefthook.dev/configuration/run.html
- https://lefthook.dev/configuration/glob.html
- https://github.com/evilmartians/lefthook
- https://oxc.rs/docs/guide/usage/formatter/cli.html
- https://oxc.rs/docs/guide/usage/linter/automatic-fixes
- https://dev.to/renanpaixao/how-to-set-up-lefthook-to-handle-git-hooks-in-react-applications-527i
- https://dev.to/ramunarasinga-11/lefthookyml-in-n8n-codebase-5f4c

## 2026-01-17: review-042 completed

**Task**: Verify Husky setup for ESM projects
**Check**: Does Husky work well with ESM-only TypeScript projects?

**Finding**:
- YES, Husky 9.x works well with ESM-only TypeScript projects but requires specific configuration
- Current version is v9.1.7 (January 2026)
- Key setup requirements:
  1. Use `npx husky init` (not deprecated `husky install` or `npx husky add`)
  2. package.json needs `"type": "module"` and `"prepare": "husky"` script
  3. lint-staged supports ESM format in lint-staged.config.js with `export default {}` syntax
  4. .husky/pre-commit file simply contains `npx lint-staged`

**ESM-specific Configuration:**

**package.json:**
```json
{
  "type": "module",
  "scripts": {
    "prepare": "husky"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx}": ["eslint --fix", "prettier --write"],
    "*.{css,md,json}": ["prettier --write"]
  },
  "devDependencies": {
    "husky": "^9.1.7",
    "lint-staged": "^15.2.10"
  }
}
```

**lint-staged.config.js (ESM format):**
```js
export default {
  '*.{js,jsx,ts,tsx}': ['eslint --fix', 'prettier --write'],
  '*.{json,css,md}': ['prettier --write']
};
```

**.husky/pre-commit:**
```sh
npx lint-staged
```

**CAVEAT - commitlint ESM issues:**
- Tools like commitlint may error with "require() of ES modules is not supported" when `"type": "module"` is in package.json
- Workaround: Rename `commitlint.config.js` to `commitlint.config.cjs` (CommonJS) or `commitlint.config.mjs` (ESM)
- commitlint.config.cjs example:
```js
module.exports = {
  extends: ['@commitlint/config-conventional']
};
```

**CI Environment Considerations:**
- If installing only dependencies (not devDependencies), the `"prepare": "husky"` script may fail
- Workaround: Use `"prepare": "husky || true"` to prevent CI failures
- Alternative: Check for environment variable like `CI` before running husky

**Key Notes:**
- Husky 9 is itself an ESM package (requires Node.js 18+)
- Old commands `npx husky install` and `npx husky add` are deprecated in Husky 9.x
- Use `npx husky init` to set up hooks automatically
- lint-staged v15.x fully supports ESM configuration files

**Action Required**: Add 'Husky ESM Configuration' subsection to PLAN.md documenting: (1) Required package.json settings for ESM projects, (2) lint-staged.config.js ESM format, (3) commitlint.config.cjs workaround for ESM projects, (4) CI environment considerations.

**Sources**:
- https://github.com/typicode/husky
- https://typicode.github.io/husky/get-started.html
- https://typicode.github.io/husky/how-to.html
- https://github.com/typicode/husky/issues/727
- https://github.com/lint-staged/lint-staged
- https://betterstack.com/community/guides/scaling-nodejs/husky-and-lint-staged/
- https://commitlint.js.org/reference/configuration.html
- https://github.com/conventional-changelog/commitlint/issues/902

## 2026-01-17: review-033 completed

**Task**: Verify Claude Code settings.json format
**Check**: Is the permissions.deny format correct for Claude Code?

**Finding**:
- The permissions.deny format uses `Tool(pattern)` syntax in Claude Code settings.json
- Correct syntax examples:
  - **Read**: Gitignore-style file patterns - `Read(**/.env)`, `Read(**/*.key)`, `Read(**/secrets/**)`
  - **Edit/Write**: Same gitignore-style patterns - `Edit(**/.env)`, `Write(**/config/*)`
  - **Bash**: Command patterns with `command:args` format - `Bash(sudo:*)`, `Bash(rm:-rf:*)`, `Bash(curl:*)`
  - **WebFetch**: Domain specification - `WebFetch(domain:example.com)` (wildcards NOT supported)
- Settings file hierarchy (highest to lowest precedence):
  1. `.claude/settings.local.json` - Project settings (not tracked in git)
  2. `.claude/settings.json` - Project settings (tracked in git, shared with team)
  3. `~/.claude/settings.json` - User settings (applies to all projects)
  4. Managed settings (system-level for enterprise policies)

**CRITICAL ISSUE - Known Enforcement Bugs**:
- Multiple GitHub issues report that `permissions.deny` rules are NOT being enforced for Read, Write, and Edit tools as of late 2025:
  - Issue #6631: Permission deny configuration not enforced for Read/Write tools
  - Issue #6699: Critical security bug - deny permissions in settings.json not enforced
  - Issue #4467: Permission deny patterns not working for Read/Write tools
  - Issue #15921: VSCode Extension permissions not respected for Bash/Write/Edit operations
- Bash tool deny rules appear to work, but file-based tool (Read/Write/Edit) deny rules are unreliable

**Workaround - PreToolUse Hooks**:
- Until deny rules are reliably enforced, use PreToolUse hooks for reliable security enforcement
- PreToolUse hooks execute before a tool is used and can block tool calls by exiting with code 2
- Example: Block reads of sensitive files using a command hook that greps the tool input

**Action Required**: Added "Claude Code Settings Configuration" section to PLAN.md documenting:
1. Settings file locations and hierarchy
2. Correct permissions syntax with Tool(pattern) examples
3. Tool pattern reference table for Read, Edit, Write, Bash, WebFetch
4. Warning about known enforcement issues with deny rules
5. PreToolUse hook workaround example for reliable security enforcement

**Sources**:
- https://code.claude.com/docs/en/settings
- https://managed-settings.com/
- https://www.petefreitag.com/blog/claude-code-permissions/
- https://github.com/anthropics/claude-code/issues/6631
- https://github.com/anthropics/claude-code/issues/6699
- https://github.com/anthropics/claude-code/issues/4467
- https://github.com/anthropics/claude-code/issues/15921

## 2026-01-17: review-034 completed

**Task**: Verify Ralph plugin installation command
**Check**: Is '/plugin marketplace add anthropic/ralph-wiggum' the correct command?

**Finding**:
- The command '/plugin marketplace add anthropic/ralph-wiggum' is **INCORRECT** in multiple ways:
  1. It's "anthropics" (plural with 's'), not "anthropic"
  2. The `marketplace add` command is for adding a **marketplace catalog** to browse available plugins, not for installing plugins directly
  3. `ralph-wiggum` is a plugin name, not a marketplace name

**Correct Installation Flow:**
1. **Add the marketplace**: `/plugin marketplace add anthropics/claude-code`
2. **Install the plugin**: `/plugin install ralph-wiggum@claude-plugins-official`

**About Ralph Wiggum:**
- Official Anthropic plugin for autonomous development loops in Claude Code
- Named after The Simpsons character (embodies persistent iteration despite setbacks)
- Provides `/ralph-loop` and `/cancel-ralph` commands
- Usage: `/ralph-loop "task description" --max-iterations 30 --completion-promise "DONE"`

**How It Works:**
1. You provide Claude a task and optional completion criteria
2. Claude works on the task and attempts to exit when done
3. Stop Hook intercepts exit, checking for completion promise
4. If promise not found, Claude sees previous work and continues iterating
5. Each iteration refines the approach based on what broke

**Plugin Commands:**
- `/ralph-loop "task" --max-iterations N` - Start autonomous loop
- `/ralph-loop "task" --max-iterations N --completion-promise "COMPLETE"` - With auto-stop
- `/cancel-ralph` - Cancel active loop

**Action Required**: Added 'Ralph Wiggum Plugin Installation' section to PLAN.md documenting correct installation commands, basic usage, and best practices.

**Sources**:
- https://code.claude.com/docs/en/discover-plugins
- https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum
- https://www.braingrid.ai/blog/ralph-wiggum-plugin
- https://github.com/anthropics/claude-code/blob/main/plugins/ralph-wiggum/README.md
- https://venturebeat.com/technology/how-ralph-wiggum-went-from-the-simpsons-to-the-biggest-name-in-ai-right-now

## 2026-01-17: review-035 completed

**Task**: Verify @clack/prompts version
**Check**: Is ^0.8.0 the latest stable version of @clack/prompts?

**Finding**:
- ^0.8.0 is **OUTDATED**. The latest stable version is **v0.11.0** (published May 2025)
- ~2.5 million weekly downloads, actively maintained by bombshell-dev
- Key features added since 0.8.0:
  1. **v0.9.0**: `updateSettings()` function for global keybindings, `signal` option for programmatic cancellation with AbortController
  2. **v0.10.0**: `indicator` option for spinner animations (dots/timer modes), `stream` API for iterable messages
  3. **v0.11.0**: `taskLog` prompt for log output cleared on success, `format` option for note prompt, customizable spinner cancel/error messages for multilingual CLIs
- A v1.0.0 is in alpha (1.0.0-alpha.9) with ESM-only distribution, separate stop()/cancel()/error() methods, multiline message rendering, and clear() method for spinners
- v0.11.0 remains the latest stable release; v1.0 is not yet production-ready

**Action Required**: Update PLAN.md Tech Stack dependencies from `@clack/prompts: ^0.8.0` to `@clack/prompts: ^0.11.0` to get latest features including programmatic cancellation, taskLog prompt, and multilingual support.

**Sources**:
- https://www.npmjs.com/package/@clack/prompts
- https://github.com/bombshell-dev/clack/blob/main/packages/prompts/CHANGELOG.md
- https://github.com/bombshell-dev/clack/releases
- https://cloudsmith.com/navigator/npm/@clack/prompts

## 2026-01-17: review-036 completed

**Task**: Verify execa version
**Check**: Is ^9.0.0 the correct version? Check for breaking changes

**Finding**:
- ^9.0.0 IS correct and will resolve to v9.6.1 (latest, January 2026)
- Execa v9.0.0 was released May 8, 2024 with significant breaking changes from v8.x
- Key breaking changes include:
  1. **Node.js 18.19.0+ required** (dropped support for older versions)
  2. **Buffer output**: Returns `Uint8Array` instead of `Buffer` when `encoding: 'buffer'`
  3. **Encoding option values renamed**: `null` → `'buffer'`, `'utf-8'` → `'utf8'`, `'binary'` → `'latin1'`
  4. **Pipe methods unified**: `pipeStdout()`, `pipeStderr()`, `pipeAll()` renamed to single `pipe()` method
  5. **Option renames**: `signal` → `cancelSignal`, `execPath` → `nodePath`, `forceKillAfterTimeout` → `forceKillAfterDelay`
  6. **Error property renamed**: `error.killed` → `error.isTerminated`
  7. **subprocess.cancel() removed**: Use `subprocess.kill()` instead
  8. **Verbose option changed**: Boolean → string enum (`false` → `'none'`, `true` → `'short'`)
  9. **execaCommand() deprecated** (v9.2.0): Use `parseCommandString()` + `execa()` instead
  10. **Default serialization**: Changed from `'json'` to `'advanced'`
- The package receives 105M+ weekly downloads and is actively maintained
- Execa is a "Key ecosystem project" in the npm registry

**Action Required**: Added dependency version specifications to PLAN.md Tech Stack section including `execa: ^9.0.0` and documented key breaking changes in a new "Execa v9 Migration Notes" subsection.

**Sources**:
- https://github.com/sindresorhus/execa/releases/tag/v9.0.0
- https://github.com/sindresorhus/execa/releases
- https://www.npmjs.com/package/execa
- https://www.jsdocs.io/package/execa
- https://medium.com/@ehmicky/execa-9-release-d0d5daaa097f

## 2026-01-17: review-037 completed

**Task**: Verify directory structure completeness
**Check**: Missing scaffolders for remix.ts, astro.ts, rn-cli.ts

**Finding**:
- The PLAN.md directory structure was **INCOMPLETE**
- It only listed 4 scaffolder files (nextjs.ts, tanstack.ts, expo.ts, base.ts) but the Scaffolding Strategy table listed 8 frameworks
- Missing scaffolder files that were added:
  1. `react-router.ts` - For React Router v7 (note: Remix merged into React Router v7 per review-012)
  2. `rn-cli.ts` - For React Native CLI (wraps `npx react-native init`)
  3. `astro.ts` - For Astro (wraps `create astro`)
  4. `api.ts` - For Hono/Elysia API templates

**Changes Made**:
1. Updated PLAN.md directory structure to include all 8 scaffolder files:
   - nextjs.ts (wraps create-next-app)
   - tanstack.ts (wraps @tanstack/create-start)
   - react-router.ts (wraps create-react-router)
   - expo.ts (wraps create-expo-stack)
   - rn-cli.ts (wraps npx react-native init)
   - astro.ts (wraps create astro)
   - api.ts (own templates for Hono/Elysia)
   - base.ts (minimal TypeScript template)

2. Updated prd.json impl-015:
   - Changed task from "Implement Remix scaffolder wrapper" to "Implement React Router v7 scaffolder wrapper"
   - Changed file from "src/scaffolders/remix.ts" to "src/scaffolders/react-router.ts"

**Action Required**: None - directory structure now matches scaffolding strategy

**Sources**:
- PLAN.md Scaffolding Strategy table (lines 391-399)
- PLAN.md Directory Structure (lines 440-448)
- review-012 finding (Remix merged into React Router v7)

## 2026-01-17: review-038 completed

**Task**: Verify presets completeness
**Check**: Missing presets for content (Astro) and universal (Expo + Tamagui)

**Finding**:
YES, both presets were missing from PLAN.md:

**1. Content Preset (Astro)** - Was NOT defined despite Astro being a supported framework:
- Astro 5's Content Layer API provides 5x faster builds and 50% less memory usage
- MDX + Content Collections enable TypeScript type-safety for frontmatter
- CMS options: Markdown files (default), Sanity, Contentful, TinaCMS, PayloadCMS
- Deploy: Cloudflare Pages (recommended), Vercel, Netlify
- Server Islands allow combining static content with dynamic sections (auth, personalization)

**2. Universal Preset (Expo + Tamagui)** - Was NOT defined despite Universal platform being listed:
- Official scaffolder: `yarn create tamagui@latest --template expo-router`
- Sets up monorepo with Expo + Next.js + Solito for true universal apps
- Tamagui's optimizing compiler extracts CSS on web for production performance
- Expo Router provides same file-based routing for both web and native
- Code shared in `packages/app/features` with platform-specific entry points
- Note: Requires Yarn 4.4.0+ (run `yarn set version stable` first)

**Changes Made**:
1. Added "Content Preset (`--preset content`)" to PLAN.md with complete configuration
2. Added "Universal Preset (`--preset universal`)" to PLAN.md with complete configuration
3. Added `content.ts` and `universal.ts` to presets directory structure
4. Updated Command Structure to include `--preset content`, `--preset universal`, `--preset fullstack`

**Action Required**: None - presets are now complete

**Sources**:
- https://tamagui.dev/docs/guides/create-tamagui-app
- https://github.com/tamagui/starter-free
- https://astro.build/blog/whats-new-november-2025/
- https://inhaq.com/blog/getting-started-with-astro-content-collections/
- https://hygraph.com/blog/astro-cms
- https://dev.to/hasan_py/setup-your-universal-app-with-react-native-expo-router-tamagui-and-storybook-28m6

## 2026-01-17: review-039 completed

**Task**: Verify React Native CLI warning is helpful
**Check**: Warning about Xcode/Android Studio - should we offer to install prerequisites?

**Finding**:
- The warning SHOULD be helpful and actionable, not just informational
- React Native CLI requires significant local setup:
  - **iOS**: Xcode (Mac App Store) + Command Line Tools + CocoaPods
  - **Android**: Android Studio + Android SDK + ANDROID_HOME env var + JDK 17+
  - **Estimated setup time**: ~1 hour if tools not already installed
- **Should NOT offer to install prerequisites** - too complex, OS-dependent, and error-prone
- **Instead, the wizard should**:
  1. Display clear prerequisites list with estimated setup time
  2. Offer to switch to Expo as easier alternative (same RN code, cloud builds via EAS)
  3. Detect if tools are already installed (`xcode-select -p`, `$ANDROID_HOME`)
  4. Provide clear decision guidance on when RN CLI is actually needed

**When React Native CLI is actually recommended:**
- Custom native modules requiring direct native code access
- Brownfield apps (integrating RN into existing native app)
- Performance-critical apps needing native-level optimization
- Teams with existing native iOS/Android expertise

**Key insight**: The React Native team now recommends Expo/framework-first approach for new projects. The question should be "Do I have a compelling reason NOT to use Expo?" rather than "Why Expo?"

**Action Required**: Added comprehensive "React Native CLI Prerequisites Warning" section to PLAN.md including:
1. Full prerequisites list for iOS and Android development
2. Estimated setup time (~1 hour)
3. Alternative recommendation (Expo) with benefits
4. Decision guidance for when RN CLI is appropriate
5. Wizard implementation notes for detecting installed tools

**Sources**:
- https://reactnative.dev/docs/set-up-your-environment
- https://medium.com/react-native-journal/expo-vs-react-native-cli-in-2025-which-one-should-you-choose-7badd45e5fa7
- https://dev.to/wafa_bergaoui/expo-or-react-native-cli-in-2025-lets-settle-this-cl1
- https://dev.to/devi_green_00f82b6d705/its-2025-you-should-probably-be-using-expo-for-react-native-407a
- https://getstream.io/blog/react-native-android-ios-setup/
- https://github.com/anasyd/Install-RN-on-MacOS

## 2026-01-17: review-040 completed

**Task**: Verify Docker setup instructions clarity
**Check**: Is the post-scaffold Docker setup flow clear enough for beginners?

**Finding**:
- The PLAN.md Docker Configuration section covers the technical approaches well (Docker Sandbox, Custom Dockerfile, DevContainer) but lacks a beginner-friendly post-scaffold flow
- Key gaps identified:
  1. No clear "Quick Start" path prioritizing the simplest method (`docker sandbox run claude`)
  2. Prerequisites scattered rather than presented as a pre-scaffold checklist
  3. Missing post-scaffold instructions specific to what bootstralph generates
  4. No troubleshooting guidance for common first-time issues (Docker not running, API key problems, permission errors)
- Official Docker docs show a simple 3-step flow: run `docker sandbox run claude`, enter API key on first run, credentials persist automatically
- VS Code devcontainer flow requires 4 steps but is well-documented in official Anthropic docs
- The custom Dockerfile approach is most complex and should be marked as "advanced"

**Changes Made**:
1. Added "Post-Scaffold Docker Quick Start" section to PLAN.md with:
   - Prerequisites checklist (Docker Desktop required, VS Code optional)
   - Path A: Docker Desktop Sandbox (2 minutes, recommended for beginners)
   - Path B: VS Code Dev Container (5 minutes, recommended for VS Code users)
   - Path C: Custom Dockerfile (10 minutes, advanced)
   - Troubleshooting table for common issues
   - Implementation notes for environment detection in `src/ralph/sandbox.ts`
2. Added guidance for what files bootstralph should generate based on detected environment

**Action Required**: None - section added with complete beginner-friendly documentation

**Sources**:
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://code.claude.com/docs/en/devcontainer
- https://www.arsturn.com/blog/how-to-run-claude-code-securely-in-a-docker-container
- https://github.com/RchGrav/claudebox


## 2026-01-17: impl-001 completed

**Task**: Initialize project with bun and TypeScript
**Files**: package.json, tsconfig.json, tsup.config.ts, src/index.ts

**Changes Made**:
1. Updated `package.json` with:
   - Changed `type: "module"` for ESM support
   - Added proper exports configuration (types first, then import, then require)
   - Added bin entry for CLI execution
   - Added dependencies: @clack/prompts ^0.11.0, detect-package-manager, execa ^9.0.0, fs-extra
   - Added devDependencies: @types/fs-extra, @types/node, tsup, typescript, vitest
   - Added scripts: dev, build, typecheck, test, lint, format
   - Set engines.node >= 18.19.0 (required by execa v9)

2. Created `tsconfig.json` with:
   - ES2022 target with ESNext modules
   - bundler moduleResolution for modern bundlers
   - Strict TypeScript settings including verbatimModuleSyntax, noUncheckedIndexedAccess
   - noEmit true (tsup handles compilation)

3. Created `tsup.config.ts` with:
   - ESM and CJS dual output
   - Type declarations enabled
   - Node 18 target
   - Shebang banner for CLI execution
   - Sourcemaps enabled

4. Created basic `src/index.ts` entry point with:
   - @clack/prompts import
   - Basic main function with intro/outro
   - Error handling

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully
- CLI executes correctly: `node dist/index.js` shows clack prompts

**Note**: bun is not available in the environment, so npm was used for installation. The project is configured to work with bun (scripts use `bun run` for prepublishOnly) but falls back gracefully.

## 2026-01-17: impl-002 completed

**Task**: Create CLI entry point with @clack/prompts
**Files**: src/index.ts

**Changes Made**:
1. Implemented full CLI entry point with argument parsing:
   - `parseArgs()` function to parse command-line arguments
   - Supports `create`, `init`, `add`, `help`, and `version` commands
   - Handles `--preset` / `-p` flag with validation against 6 valid presets
   - Shorthand support: `bootstralph my-app` treated as `bootstralph create my-app`

2. Command handlers implemented:
   - `showVersion()`: Displays version from VERSION constant
   - `showHelp()`: Comprehensive help text with usage examples
   - `handleCreate()`: Main wizard entry point with project name prompt
   - `handleInit()`: Placeholder for init command (impl-025)
   - `handleAdd()`: Placeholder for add command (impl-026)

3. Key features:
   - Project name validation (alphanumeric, hyphens, underscores)
   - Interactive prompt for project name if not provided
   - Preset display when specified
   - Spinner animation for initialization
   - Informative placeholder showing upcoming implementation tasks
   - Graceful error handling with clack's log.error

4. Removed shebang from source file (tsup adds it via banner config)

5. Fixed TypeScript strict type issues:
   - Used explicit `string | undefined` and `Preset | undefined` types
   - Added all required properties to return statements

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully (ESM, CJS, and DTS output)
- `node dist/index.js --help` shows correct help text
- `node dist/index.js --version` shows "bootstralph v0.1.0"
- `node dist/index.js create test-app --preset saas` shows full wizard flow

**CLI Command Examples**:
```bash
bootstralph --help              # Show help
bootstralph --version           # Show version
bootstralph create my-app       # Interactive create wizard
bootstralph create my-app -p saas  # With preset
bootstralph my-app              # Shorthand for create
bootstralph init                # Init in existing project (placeholder)
bootstralph add auth            # Add feature (placeholder)
```

## 2026-01-17: impl-003 completed

**Task**: Implement compatibility matrix data structure
**Files**: src/compatibility/matrix.ts

**Changes Made**:
1. Created comprehensive `src/compatibility/matrix.ts` with:
   - **Core Types**: Platform, Framework, Styling, StateManagement, ORM, Backend, AuthProvider, Linter, Formatter, UnitTestFramework, E2ETestFramework, DeploymentTarget, PreCommitTool, Bundler, Routing
   - **Platform Configuration**: PLATFORMS record defining web, mobile, universal, and api platforms with their compatible frameworks
   - **Framework Configuration**: FRAMEWORKS record with complete config for all 8 frameworks (Next.js, TanStack Start, React Router v7, Astro, Expo, React Native CLI, Hono, Elysia) including bundler, routing, styling, state, orm, backend, auth, testing, deployment options
   - **Incompatibility Rules**: 19 rules defining what cannot be used together (e.g., Next.js + TanStack Router, Drizzle + Prisma, Biome + ESLint, Expo + Vitest)
   - **Edge Runtime Compatibility**: Matrix for Cloudflare, Vercel, Netlify, Railway, Fly.io with ORM support details
   - **Styling Compatibility Matrix**: Per-platform styling support (web, expo, reactNative, universal)
   - **Testing Compatibility Matrix**: Unit and E2E testing framework support per platform
   - **Linter/Formatter Configuration**: oxlint, biome, eslint linters and oxfmt, prettier, biome formatters with metadata
   - **Default Recommendations**: DEFAULTS object with recommended tools per platform
   - **Skills Matrix**: SKILLS_MATRIX defining which skills to install based on selected stack
   - **Helper Functions**:
     - `getFrameworksForPlatform()` - Get frameworks for a platform
     - `getFrameworkConfig()` - Get full framework configuration
     - `areSelectionsCompatible()` - Check if two selections are compatible
     - `getIncompatibleOptions()` - Get all incompatible options for a selection
     - `getStylingForPlatform()` - Get available styling options for a platform
     - `getRecommendedStyling()` - Get recommended styling for a platform
     - `checkEdgeORMCompatibility()` - Validate ORM + edge deployment compatibility
     - `getSkillsForConfig()` - Get skills to install for a given configuration

2. All data structures derived from PLAN.md compatibility matrices and review findings

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully

## 2026-01-17: impl-004 completed

**Task**: Implement option filtering logic
**Files**: src/compatibility/filters.ts

**Changes Made**:
1. Created comprehensive `src/compatibility/filters.ts` with:
   - **WizardSelections interface**: Type for tracking current wizard selections (platform, framework, styling, state, orm, backend, auth, linter, formatter, testing, deployment)
   - **FilteredOption<T> interface**: Generic type for options with metadata (value, label, description, recommended, disabled, disabledReason)
   - **Framework Filters**:
     - `getAvailableFrameworks()` - Get frameworks for a platform with recommended flag
     - `getRecommendedFramework()` - Internal helper for default framework per platform
   - **Styling Filters**:
     - `getAvailableStyling()` - Get styling options filtered by platform AND framework support
     - Helper functions for styling labels and descriptions
   - **State Management Filters**:
     - `getAvailableStateManagement()` - Get state options based on framework
   - **ORM Filters**:
     - `getAvailableORM()` - Get ORM options based on framework (Drizzle recommended)
   - **Backend Filters**:
     - `getAvailableBackend()` - Get backend options based on framework
   - **Auth Filters**:
     - `getAvailableAuth()` - Get auth options with dynamic recommendations based on backend selection
   - **Linter & Formatter Filters**:
     - `getAvailableLinters()` - Get linter options with default recommendation
     - `shouldShowFormatterQuestion()` - Returns false for Biome (handles both lint+format)
     - `getAvailableFormatters()` - Get formatter options, auto-selects biome if biome linter chosen
   - **Testing Filters**:
     - `getAvailableUnitTesting()` - Get unit testing frameworks with incompatibility filtering
     - `getAvailableE2ETesting()` - Get E2E testing frameworks with incompatibility filtering
   - **Deployment Filters**:
     - `getAvailableDeployment()` - Get deployment targets based on framework
     - `getRecommendedDeployment()` - Internal helper for optimal deployment per framework
   - **Generic Filtering**:
     - `checkIncompatibility()` - Internal helper to check incompatibility rules
     - `filterOptions()` - Generic filter function for any option list
   - **Validation**:
     - `validateSelections()` - Validate all selections are compatible, returns errors array

2. Key implementation details:
   - All filter functions return `FilteredOption<T>[]` with consistent metadata for UI display
   - Biome linter automatically skips formatter question (implements review-010 finding)
   - Auth recommendations change based on backend (Supabase Auth recommended when Supabase backend selected)
   - Deployment recommendations are framework-specific (Vercel for Next.js, Cloudflare for Hono, EAS for Expo)
   - Mobile frameworks (Expo, React Native CLI) filter out web-only testing tools (Vitest, Playwright, Cypress)

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully

## 2026-01-17: impl-005 completed

**Task**: Implement combination validators
**Files**: src/compatibility/validators.ts

**Changes Made**:
1. Created comprehensive `src/compatibility/validators.ts` with:
   - **ValidationResult interface**: Standardized return type with valid, warnings, and errors arrays
   - **ValidationWarning/ValidationError interfaces**: Structured types with code, message, suggestion, and affectedFields
   - **Edge Runtime Validators**:
     - `isEdgeDeployment()` - Check if deployment target is edge (Cloudflare, Vercel, Netlify)
     - `validateEdgeORMCompatibility()` - Validates ORM + edge deployment combinations, warns about Prisma Accelerate requirements
   - **Linter + Formatter Validators**:
     - `validateLinterFormatterCombination()` - Ensures Biome users don't also select a separate formatter
   - **Auth + Backend Validators**:
     - `validateAuthBackendCombination()` - Warns when using Supabase Auth without Supabase backend or vice versa
   - **Framework + Platform Validators**:
     - `validateFrameworkPlatform()` - Ensures framework is compatible with selected platform
   - **Mobile E2E Testing Validators**:
     - `validateMobileE2ETesting()` - Ensures mobile frameworks don't use web E2E tools (Playwright/Cypress)
   - **React Native Prerequisites**:
     - `checkReactNativePrerequisites()` - Template for runtime checks of Xcode, Android SDK, CocoaPods
   - **Complete Validation**:
     - `validateAllSelections()` - Runs all validators on complete wizard selections
     - `validateIncompatibilityRules()` - Checks all INCOMPATIBILITY_RULES against selections
   - **Post-Selection Warnings**:
     - `generatePostSelectionWarnings()` - Generates informational warnings for display (oxfmt alpha, RSC not supported, RN CLI prerequisites, EAS build tips, Prisma edge)
   - **Skill Validation**:
     - `validateSkillAvailability()` - Validates recommended skills are being installed

2. Key implementation details:
   - Validators return structured results with codes, messages, and suggestions
   - Edge deployment validation implements review-008 findings (Prisma + Cloudflare/Vercel Edge requires Accelerate)
   - All validators are composable and can be run individually or together via `validateAllSelections()`
   - Post-selection warnings provide helpful tips without blocking the wizard

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully


## 2026-01-17: impl-006 completed

**Task**: Create project type prompt
**Files**: src/prompts/project-type.ts

**Changes Made**:
1. Created `src/prompts/project-type.ts` with:
   - **ProjectTypeResult interface**: Return type containing the selected platform
   - **PLATFORM_DISPLAY config**: Display labels and hints for each platform (Web, Mobile, Universal, API Only)
   - **promptProjectType()**: Main prompt function using @clack/prompts select
     - Shows all 4 platform options with hints describing each
     - Returns undefined if user cancels
     - Default selection is "web"
   - **getPlatformInfo()**: Helper to get platform name, description, and available frameworks
   - **isValidPlatform()**: Type guard to validate platform string values

2. Key implementation details:
   - Uses `p.select<Platform>()` from @clack/prompts for interactive selection
   - Integrates with PLATFORMS configuration from matrix.ts
   - Options show labels (Web, Mobile, etc.) with hint text (SSR/SSG/SPA, iOS and Android, etc.)
   - Handles cancellation gracefully by returning undefined

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully

## 2026-01-17: impl-007 completed

**Task**: Create framework selection prompt with filtering
**Files**: src/prompts/framework.ts

**Changes Made**:
1. Created `src/prompts/framework.ts` with:
   - **FrameworkResult interface**: Return type containing the selected framework
   - **promptFramework(platform)**: Main prompt function using @clack/prompts select
     - Fetches available frameworks for the platform using `getAvailableFrameworks()` from filters.ts
     - Auto-selects if only one framework is available for the platform
     - Shows recommended frameworks with "(Recommended)" label suffix
     - Uses framework description as hint text
     - Sets initial value to recommended framework or first available
     - Returns undefined if user cancels
   - **getFrameworkInfo(framework)**: Get framework name, description, scaffoldCommand, and notes
   - **getFrameworkDisplayName(framework)**: Get just the display name for a framework
   - **isValidFrameworkForPlatform(framework, platform)**: Type guard to validate framework is available for platform
   - **getRecommendedFramework(platform)**: Get the recommended framework for a platform
   - **getFrameworkOptions(platform)**: Get full FilteredOption array for custom UI rendering

2. Key implementation details:
   - Uses filtering logic from `src/compatibility/filters.ts` to show only compatible frameworks
   - Handles TypeScript's exactOptionalPropertyTypes by conditionally adding optional properties
   - Follows same patterns as project-type.ts for consistency
   - Auto-selects framework when only one is available (e.g., Universal platform only has Expo)
   - Integrates with FRAMEWORKS config from matrix.ts for full metadata access

**Verification**:
- `npm run typecheck` passes
- `npm run build` completes successfully
