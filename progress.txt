## 2026-01-17: review-001 completed

**Task**: Verify Next.js incompatibility rules are complete
**Check**: Can Next.js actually use React Router? Are there edge cases where TanStack Router works with Next.js?

**Finding**:
- React Router CAN technically be used in Next.js but loses SSR/SEO benefits and is not recommended
- TanStack Router conflicts with Next.js History API - workarounds exist (memory history, route groups, patching) but you lose SSR benefits
- The incompatibility rules in PLAN.md are correct: Next.js should not use TanStack Router or React Router as primary routing

**Action Required**: None - the PLAN.md incompatibility rules are accurate

**Sources**:
- https://github.com/TanStack/router/discussions/346
- https://thenewstack.io/next-js-react-router-tanstack-when-to-use-each/
- https://tanstack.com/start/latest/docs/framework/react/comparison
- https://medium.com/@cubode/client-side-routing-in-nextjs-15-tanstack-router-integration-d2e3ce1c6f56

## 2026-01-17: review-002 completed

**Task**: Verify TanStack Start + RSC compatibility status
**Check**: Is RSC support still 'coming soon' or has it shipped? Check TanStack changelog

**Finding**:
- RSC support is still "coming soon" as of January 2026
- TanStack Start v1 is in Release Candidate stage (feature-complete, API stable)
- Official docs state: "we are actively working on integration and expect to support them in the near future"
- RSC will land as a non-breaking v1.x addition
- TanStack is taking a measured approach to ensure RSC integration aligns with type-safety and flexibility principles
- Server Functions already support returning JSX/elements from createServerFn

**Action Required**: None - the PLAN.md statement "rsc: Not yet supported (coming soon)" is accurate

**Sources**:
- https://tanstack.com/start/latest/docs/framework/react/overview
- https://tanstack.com/blog/announcing-tanstack-start-v1
- https://github.com/TanStack/router/discussions/802
- https://strapi.io/blog/building-better-apps-with-tan-stack-start-and-tanner-linsley

## 2026-01-17: review-003 completed

**Task**: Verify Expo + Vitest incompatibility
**Check**: Is vitest-react-native mature enough now? Check latest status

**Finding**:
- vitest-react-native is NOT production-ready - the package explicitly warns "This package is still WIP"
- Current version is only 0.1.5 with no official releases, only 76 GitHub stars and 5 forks
- Community feedback describes it as "not very reliable" with testing-library functions like `getByTestId` and `getByText`
- Combining React-Native-Testing-Library + React-Native + Expo + Vitest is described as "an endless pit of issues"
- React Native Testing Library maintainers state they "try not to add any code that would force running on Jest" but haven't tested vitest-react-native themselves
- The main Vitest framework is at v4.0.17, but vitest-react-native remains experimental

**Action Required**: None - the PLAN.md incompatibility rules are correct: Jest is required for React Native/Expo, and Vitest should only be used for web projects

**Sources**:
- https://github.com/sheremet-va/vitest-react-native
- https://www.npmjs.com/package/vitest-react-native/v/0.1.5
- https://github.com/callstack/react-native-testing-library/discussions/1142

## 2026-01-17: review-004 completed

**Task**: Verify Uniwind stability
**Check**: Is Uniwind production-ready or still in beta? Check release status

**Finding**:
- Uniwind IS production-ready - official docs explicitly state "Both versions are production-ready and actively maintained"
- Current version is v1.2.4 (released January 13, 2026)
- Repository created July 29, 2025, now has 1.2k GitHub stars and 21 releases
- Offers 2x performance improvement over NativeWind
- HeroUI Native has fully migrated to Uniwind, reporting 250% performance boost
- Both free (MIT license) and Pro ($99/seat/year with C++ engine) versions available
- Built by the creators of Unistyles, a proven React Native styling solution

**Action Required**: None - the PLAN.md recommendation of Uniwind as default mobile styling is appropriate

**Sources**:
- https://github.com/uni-stack/uniwind
- https://uniwind.dev/
- https://docs.uniwind.dev/pro-version
- https://www.reactnativecrossroads.com/posts/introducing-uniwind-the-fastest-tailwind-bindings-for-react-native/

## 2026-01-17: review-005 completed

**Task**: Verify oxfmt alpha stability
**Check**: oxfmt is listed as alpha - is it stable enough for default recommendation?

**Finding**:
- Oxfmt is currently in alpha (announced December 1, 2025) with beta ETA Q1 2026
- Current version is v0.24.0 (January 12, 2026) with active weekly releases
- Passes 95% of Prettier's JavaScript and TypeScript tests
- 30x faster than Prettier, 3x faster than Biome
- Professionally maintained by VoidZero/Oxc team with frequent bug fixes
- SST's opencode has added experimental oxfmt support, indicating real-world adoption
- Will be integrated into Vite+ as `vite fmt` (public preview early 2026)
- For CLI scaffolder targeting developers wanting cutting-edge tools, oxfmt is reasonable default

**Action Required**: Consider adding Prettier as explicit fallback option for users who need 100% stability. Current PLAN.md recommendation is acceptable.

**Sources**:
- https://oxc.rs/blog/2025-12-01-oxfmt-alpha.html
- https://voidzero.dev/posts/announcing-oxfmt-alpha
- https://github.com/oxc-project/oxc/releases
- https://github.com/sst/opencode/pull/5620
- https://voidzero.dev/posts/announcing-vite-plus

## 2026-01-17: review-006 completed

**Task**: Check Universal platform flow logic
**Check**: If user selects Universal, we auto-select Expo + Tamagui. But should we ask about styling?

**Finding**:
- The wizard SHOULD ask about styling for Universal platform, not auto-select Tamagui
- While Tamagui is the best option for true universal apps (75k weekly downloads, optimizing compiler, extracts CSS on web), there are valid alternatives:
  - **NativeWind** (403k weekly downloads) - Familiar Tailwind approach, larger community, compiles utilities ahead of time
  - **Gluestack UI v3** - Combines NativeWind's styling engine with accessible, unstyled components
- Teams already using Tailwind may strongly prefer NativeWind over Tamagui's unique syntax
- Tamagui has a steeper learning curve that may not suit all teams
- Auto-selecting Tamagui ignores these valid use cases

**Action Required**: Update PLAN.md to:
1. For Universal platform, ask styling question with options:
   - Tamagui (Recommended) - Best performance, comprehensive design system
   - NativeWind - Familiar Tailwind approach, larger community
   - Gluestack UI - NativeWind + accessible components
2. Update wizard flow description to show styling is NOT auto-selected for Universal

**Sources**:
- https://blog.logrocket.com/best-react-native-ui-component-libraries/
- https://blog.logrocket.com/unistyles-vs-tamagui-cross-platform-react-native-styles/
- https://tamagui.dev/
- https://www.producthunt.com/products/tamagui/alternatives

## 2026-01-17: review-007 completed

**Task**: Check Astro + Auth flow
**Check**: Astro uses React islands for auth - is the UX clear that auth only works in islands?

**Finding**:
- The premise of this review was INCORRECT - Astro authentication does NOT only work in React islands
- **Clerk** has a native Astro SDK (`@clerk/astro`) with server-side middleware, route protection, and Astro components
- **better-auth** also supports server-side authentication in Astro without requiring React islands
- Both providers use `clerkMiddleware()` / auth middleware for route protection that runs server-side
- React islands are optional - primarily for interactive UI components (login buttons, user menus)
- The PLAN.md line "auth: better-auth, Clerk (via React islands)" was misleading

**Action Required**: Updated PLAN.md Astro section to clarify:
- Changed "auth: better-auth, Clerk (via React islands)" to "auth: better-auth, Clerk (native Astro SDKs with server-side middleware)"
- Updated note to "Use React islands for interactive UI; auth works server-side via middleware"

**Sources**:
- https://docs.astro.build/en/guides/authentication/
- https://clerk.com/docs/quickstarts/astro
- https://dev.to/isnan__h/authenticating-users-in-astro-react-apps-with-better-auth-3loe
- https://www.better-auth.com/docs/reference/resources

## 2026-01-17: review-008 completed

**Task**: Check feature selection order
**Check**: Features are selected before deployment. Should deployment affect available features (e.g., edge functions)?

**Finding**:
- The current flow (features before deployment) is CORRECT
- Edge runtimes have significant limitations that require post-selection validation:
  - **Cloudflare Workers**: V8 isolates, 3MB bundle limit on free plan, TCP connection restrictions
  - **Vercel Edge**: V8 isolates, limited Node.js APIs
  - **Netlify Edge**: Deno-based runtime, different API surface
- ORM compatibility varies by deployment platform:
  - **Prisma**: Requires Prisma Accelerate or Prisma Postgres for edge (bundle too large, TCP issues)
  - **Drizzle**: Edge-compatible but needs specific drivers (@libsql/client for Turso, Neon serverless, PlanetScale serverless)
- Most features work on most platforms, so asking deployment first adds unnecessary cognitive overhead
- Better UX pattern: Let users select features first, then validate against deployment and warn about incompatibilities with suggested alternatives

**Action Required**: Add post-deployment validation step to wizard:
1. Check for edge runtime incompatibilities in src/compatibility/validators.ts
2. When user selects Cloudflare/Vercel Edge/Netlify Edge AND Prisma, warn that Prisma Accelerate is required OR suggest Drizzle with edge-compatible driver
3. Added "Edge Runtime Compatibility" section to PLAN.md with detailed ORM compatibility matrix

**Sources**:
- https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview
- https://orm.drizzle.team/docs/tutorials/drizzle-with-vercel-edge-functions
- https://github.com/drizzle-team/drizzle-orm/discussions/3146
- https://dev.to/dataformathub/cloudflare-vs-vercel-vs-netlify-the-truth-about-edge-performance-2026-50h0
- https://github.com/t3-oss/create-t3-app/issues/1452

## 2026-01-17: review-009 completed

**Task**: Check mobile E2E testing in recommended toolset
**Check**: Recommended toolset says 'Playwright/Maestro' but should show only Maestro for mobile

**Finding**:
- The PLAN.md is ALREADY CORRECT - E2E testing recommendations are clearly platform-specific
- Key Decisions table shows "Playwright (web), Maestro (mobile)" with explicit platform separation
- E2E Testing Compatibility matrix (lines 214-219) shows:
  - Playwright: ✅ Web, ❌ Expo, ❌ React Native
  - Maestro: ❌ Web, ✅ Expo, ✅ React Native
- Expo section (line 111) shows "Jest (unit), Maestro (e2e, recommended), Detox" - only mobile tools
- Incompatibility Rules explicitly state "Expo | Playwright/Cypress | Use Maestro/Detox instead"
- There is no combined "Playwright/Maestro" recommendation - the review task premise was incorrect

**Action Required**: None - the PLAN.md already correctly separates E2E testing recommendations by platform

**Sources**:
- PLAN.md lines 214-219 (E2E Testing Compatibility matrix)
- PLAN.md line 49 (Incompatibility Rules)
- PLAN.md line 111 (Expo testing recommendations)
- PLAN.md line 375 (Key Decisions Summary)

## 2026-01-17: review-010 completed

**Task**: Check Biome mutual exclusivity logic
**Check**: If Biome selected for linting, formatting question should be skipped. Is this clear in the flow?

**Finding**:
- The PLAN.md incompatibility rules correctly state "Biome | ESLint + Prettier | Pick one linting approach"
- The Linting/Formatting Compatibility table shows Biome is "Lint + Format" (all-in-one)
- However, there was NO explicit wizard flow documentation stating that selecting Biome should skip the formatting question
- Biome v2.x is now stable and production-ready (2025), offering 10-25x speed over ESLint+Prettier
- Biome has 97% Prettier compatibility and 200+ linting rules
- Single binary replaces 127+ npm packages (eslint, prettier, eslint-config-prettier, eslint-plugin-prettier, etc.)

**Action Required**: Added "Wizard Flow Logic: Linting & Formatting" section to PLAN.md documenting:
1. If user selects Biome for linting → skip formatting question (Biome handles both)
2. If user selects oxlint → show formatting question with oxfmt/Prettier options
3. If user selects ESLint → show formatting question with Prettier/oxfmt options
4. Implementation note: Logic goes in src/compatibility/filters.ts and src/prompts/tooling.ts

**Sources**:
- https://biomejs.dev/guides/migrate-eslint-prettier/
- https://medium.com/@pouria.r.1990/biome-js-the-unified-linter-and-formatter-replacing-eslint-and-prettier-2a752d8f357c
- https://betterstack.com/community/guides/scaling-nodejs/biome-eslint/
- https://dev.to/saswatapal/why-i-chose-biome-over-eslintprettier-20x-faster-linting-one-tool-to-rule-them-all-10kf

## 2026-01-17: review-011 completed

**Task**: Verify create-start CLI exists
**Check**: Plan says 'Wrap create-start' but TanStack Start CLI might have different name

**Finding**:
- The TanStack Start CLI EXISTS and is actively maintained
- Official package: `@tanstack/create-start` (v0.47.0 as of January 2026)
- Invocation: `npm create @tanstack/start@latest` or `pnpm create @tanstack/start@latest`
- Creates Vite-based applications with TanStack Router
- Supports multiple package managers: npm, yarn, pnpm, bun, deno
- Toolchain options: Biome or ESLint/Prettier
- Add-ons support: shadcn, tanstack-query, etc.
- MCP support for AI-assisted development
- The PLAN.md reference to 'create-start' was a shorthand - clarified to use actual npm create syntax

**Action Required**: Updated PLAN.md scaffolding table to clarify the exact command

**Sources**:
- https://www.npmjs.com/package/@tanstack/create-start
- https://tanstack.com/start/latest/docs/framework/react/quick-start
- https://github.com/TanStack/create-tsrouter-app/blob/main/cli/create-start-app/README.md

## 2026-01-17: review-012 completed

**Task**: Verify Remix scaffolder approach
**Check**: Should we use create-remix or React Router v7's scaffolder? They've merged

**Finding**:
- Remix has been MERGED into React Router v7 (announced December 2024, released December 2024)
- The official scaffolder is now `create-react-router` (v7.12.0 as of January 2026)
- Invocation: `npx create-react-router@latest my-app`
- React Router v7's "framework mode" includes all Remix features: loaders, actions, server rendering
- The `create-remix` package should NOT be used for new projects
- React Router v7 IS the successor to Remix v2 - same team, same philosophy
- Templates available via `--template remix-run/react-router-templates/<name>`
- Remix v3 exists as a separate React-less rewrite (Preact fork) but has no official docs and is not recommended

**Action Required**: Updated PLAN.md:
1. Changed scaffolding table from 'Wrap `create-remix`' to 'Wrap `create-react-router` (`npx create-react-router@latest`)'
2. Updated section title from 'Remix / React Router v7' to 'React Router v7 - Framework Mode'
3. Updated bundler from 'Vite (via Remix Vite plugin)' to 'Vite (built-in)'
4. Updated web frameworks references from 'Remix' to 'React Router v7'

**Sources**:
- https://reactrouter.com/upgrading/remix
- https://remix.run/blog/react-router-v7
- https://remix.run/blog/merging-remix-and-react-router
- https://www.npmjs.com/package/create-react-router
- https://reactrouter.com/start/framework/installation
- https://developers.cloudflare.com/workers/framework-guides/web-apps/react-router/
