## 2026-01-17: review-001 completed

**Task**: Verify Next.js incompatibility rules are complete
**Check**: Can Next.js actually use React Router? Are there edge cases where TanStack Router works with Next.js?

**Finding**:
- React Router CAN technically be used in Next.js but loses SSR/SEO benefits and is not recommended
- TanStack Router conflicts with Next.js History API - workarounds exist (memory history, route groups, patching) but you lose SSR benefits
- The incompatibility rules in PLAN.md are correct: Next.js should not use TanStack Router or React Router as primary routing

**Action Required**: None - the PLAN.md incompatibility rules are accurate

**Sources**:
- https://github.com/TanStack/router/discussions/346
- https://thenewstack.io/next-js-react-router-tanstack-when-to-use-each/
- https://tanstack.com/start/latest/docs/framework/react/comparison
- https://medium.com/@cubode/client-side-routing-in-nextjs-15-tanstack-router-integration-d2e3ce1c6f56

## 2026-01-17: review-002 completed

**Task**: Verify TanStack Start + RSC compatibility status
**Check**: Is RSC support still 'coming soon' or has it shipped? Check TanStack changelog

**Finding**:
- RSC support is still "coming soon" as of January 2026
- TanStack Start v1 is in Release Candidate stage (feature-complete, API stable)
- Official docs state: "we are actively working on integration and expect to support them in the near future"
- RSC will land as a non-breaking v1.x addition
- TanStack is taking a measured approach to ensure RSC integration aligns with type-safety and flexibility principles
- Server Functions already support returning JSX/elements from createServerFn

**Action Required**: None - the PLAN.md statement "rsc: Not yet supported (coming soon)" is accurate

**Sources**:
- https://tanstack.com/start/latest/docs/framework/react/overview
- https://tanstack.com/blog/announcing-tanstack-start-v1
- https://github.com/TanStack/router/discussions/802
- https://strapi.io/blog/building-better-apps-with-tan-stack-start-and-tanner-linsley

## 2026-01-17: review-003 completed

**Task**: Verify Expo + Vitest incompatibility
**Check**: Is vitest-react-native mature enough now? Check latest status

**Finding**:
- vitest-react-native is NOT production-ready - the package explicitly warns "This package is still WIP"
- Current version is only 0.1.5 with no official releases, only 76 GitHub stars and 5 forks
- Community feedback describes it as "not very reliable" with testing-library functions like `getByTestId` and `getByText`
- Combining React-Native-Testing-Library + React-Native + Expo + Vitest is described as "an endless pit of issues"
- React Native Testing Library maintainers state they "try not to add any code that would force running on Jest" but haven't tested vitest-react-native themselves
- The main Vitest framework is at v4.0.17, but vitest-react-native remains experimental

**Action Required**: None - the PLAN.md incompatibility rules are correct: Jest is required for React Native/Expo, and Vitest should only be used for web projects

**Sources**:
- https://github.com/sheremet-va/vitest-react-native
- https://www.npmjs.com/package/vitest-react-native/v/0.1.5
- https://github.com/callstack/react-native-testing-library/discussions/1142

## 2026-01-17: review-004 completed

**Task**: Verify Uniwind stability
**Check**: Is Uniwind production-ready or still in beta? Check release status

**Finding**:
- Uniwind IS production-ready - official docs explicitly state "Both versions are production-ready and actively maintained"
- Current version is v1.2.4 (released January 13, 2026)
- Repository created July 29, 2025, now has 1.2k GitHub stars and 21 releases
- Offers 2x performance improvement over NativeWind
- HeroUI Native has fully migrated to Uniwind, reporting 250% performance boost
- Both free (MIT license) and Pro ($99/seat/year with C++ engine) versions available
- Built by the creators of Unistyles, a proven React Native styling solution

**Action Required**: None - the PLAN.md recommendation of Uniwind as default mobile styling is appropriate

**Sources**:
- https://github.com/uni-stack/uniwind
- https://uniwind.dev/
- https://docs.uniwind.dev/pro-version
- https://www.reactnativecrossroads.com/posts/introducing-uniwind-the-fastest-tailwind-bindings-for-react-native/

## 2026-01-17: review-005 completed

**Task**: Verify oxfmt alpha stability
**Check**: oxfmt is listed as alpha - is it stable enough for default recommendation?

**Finding**:
- Oxfmt is currently in alpha (announced December 1, 2025) with beta ETA Q1 2026
- Current version is v0.24.0 (January 12, 2026) with active weekly releases
- Passes 95% of Prettier's JavaScript and TypeScript tests
- 30x faster than Prettier, 3x faster than Biome
- Professionally maintained by VoidZero/Oxc team with frequent bug fixes
- SST's opencode has added experimental oxfmt support, indicating real-world adoption
- Will be integrated into Vite+ as `vite fmt` (public preview early 2026)
- For CLI scaffolder targeting developers wanting cutting-edge tools, oxfmt is reasonable default

**Action Required**: Consider adding Prettier as explicit fallback option for users who need 100% stability. Current PLAN.md recommendation is acceptable.

**Sources**:
- https://oxc.rs/blog/2025-12-01-oxfmt-alpha.html
- https://voidzero.dev/posts/announcing-oxfmt-alpha
- https://github.com/oxc-project/oxc/releases
- https://github.com/sst/opencode/pull/5620
- https://voidzero.dev/posts/announcing-vite-plus

## 2026-01-17: review-006 completed

**Task**: Check Universal platform flow logic
**Check**: If user selects Universal, we auto-select Expo + Tamagui. But should we ask about styling?

**Finding**:
- The wizard SHOULD ask about styling for Universal platform, not auto-select Tamagui
- While Tamagui is the best option for true universal apps (75k weekly downloads, optimizing compiler, extracts CSS on web), there are valid alternatives:
  - **NativeWind** (403k weekly downloads) - Familiar Tailwind approach, larger community, compiles utilities ahead of time
  - **Gluestack UI v3** - Combines NativeWind's styling engine with accessible, unstyled components
- Teams already using Tailwind may strongly prefer NativeWind over Tamagui's unique syntax
- Tamagui has a steeper learning curve that may not suit all teams
- Auto-selecting Tamagui ignores these valid use cases

**Action Required**: Update PLAN.md to:
1. For Universal platform, ask styling question with options:
   - Tamagui (Recommended) - Best performance, comprehensive design system
   - NativeWind - Familiar Tailwind approach, larger community
   - Gluestack UI - NativeWind + accessible components
2. Update wizard flow description to show styling is NOT auto-selected for Universal

**Sources**:
- https://blog.logrocket.com/best-react-native-ui-component-libraries/
- https://blog.logrocket.com/unistyles-vs-tamagui-cross-platform-react-native-styles/
- https://tamagui.dev/
- https://www.producthunt.com/products/tamagui/alternatives

## 2026-01-17: review-007 completed

**Task**: Check Astro + Auth flow
**Check**: Astro uses React islands for auth - is the UX clear that auth only works in islands?

**Finding**:
- The premise of this review was INCORRECT - Astro authentication does NOT only work in React islands
- **Clerk** has a native Astro SDK (`@clerk/astro`) with server-side middleware, route protection, and Astro components
- **better-auth** also supports server-side authentication in Astro without requiring React islands
- Both providers use `clerkMiddleware()` / auth middleware for route protection that runs server-side
- React islands are optional - primarily for interactive UI components (login buttons, user menus)
- The PLAN.md line "auth: better-auth, Clerk (via React islands)" was misleading

**Action Required**: Updated PLAN.md Astro section to clarify:
- Changed "auth: better-auth, Clerk (via React islands)" to "auth: better-auth, Clerk (native Astro SDKs with server-side middleware)"
- Updated note to "Use React islands for interactive UI; auth works server-side via middleware"

**Sources**:
- https://docs.astro.build/en/guides/authentication/
- https://clerk.com/docs/quickstarts/astro
- https://dev.to/isnan__h/authenticating-users-in-astro-react-apps-with-better-auth-3loe
- https://www.better-auth.com/docs/reference/resources

## 2026-01-17: review-008 completed

**Task**: Check feature selection order
**Check**: Features are selected before deployment. Should deployment affect available features (e.g., edge functions)?

**Finding**:
- The current flow (features before deployment) is CORRECT
- Edge runtimes have significant limitations that require post-selection validation:
  - **Cloudflare Workers**: V8 isolates, 3MB bundle limit on free plan, TCP connection restrictions
  - **Vercel Edge**: V8 isolates, limited Node.js APIs
  - **Netlify Edge**: Deno-based runtime, different API surface
- ORM compatibility varies by deployment platform:
  - **Prisma**: Requires Prisma Accelerate or Prisma Postgres for edge (bundle too large, TCP issues)
  - **Drizzle**: Edge-compatible but needs specific drivers (@libsql/client for Turso, Neon serverless, PlanetScale serverless)
- Most features work on most platforms, so asking deployment first adds unnecessary cognitive overhead
- Better UX pattern: Let users select features first, then validate against deployment and warn about incompatibilities with suggested alternatives

**Action Required**: Add post-deployment validation step to wizard:
1. Check for edge runtime incompatibilities in src/compatibility/validators.ts
2. When user selects Cloudflare/Vercel Edge/Netlify Edge AND Prisma, warn that Prisma Accelerate is required OR suggest Drizzle with edge-compatible driver
3. Added "Edge Runtime Compatibility" section to PLAN.md with detailed ORM compatibility matrix

**Sources**:
- https://www.prisma.io/docs/orm/prisma-client/deployment/edge/overview
- https://orm.drizzle.team/docs/tutorials/drizzle-with-vercel-edge-functions
- https://github.com/drizzle-team/drizzle-orm/discussions/3146
- https://dev.to/dataformathub/cloudflare-vs-vercel-vs-netlify-the-truth-about-edge-performance-2026-50h0
- https://github.com/t3-oss/create-t3-app/issues/1452

## 2026-01-17: review-009 completed

**Task**: Check mobile E2E testing in recommended toolset
**Check**: Recommended toolset says 'Playwright/Maestro' but should show only Maestro for mobile

**Finding**:
- The PLAN.md is ALREADY CORRECT - E2E testing recommendations are clearly platform-specific
- Key Decisions table shows "Playwright (web), Maestro (mobile)" with explicit platform separation
- E2E Testing Compatibility matrix (lines 214-219) shows:
  - Playwright: ✅ Web, ❌ Expo, ❌ React Native
  - Maestro: ❌ Web, ✅ Expo, ✅ React Native
- Expo section (line 111) shows "Jest (unit), Maestro (e2e, recommended), Detox" - only mobile tools
- Incompatibility Rules explicitly state "Expo | Playwright/Cypress | Use Maestro/Detox instead"
- There is no combined "Playwright/Maestro" recommendation - the review task premise was incorrect

**Action Required**: None - the PLAN.md already correctly separates E2E testing recommendations by platform

**Sources**:
- PLAN.md lines 214-219 (E2E Testing Compatibility matrix)
- PLAN.md line 49 (Incompatibility Rules)
- PLAN.md line 111 (Expo testing recommendations)
- PLAN.md line 375 (Key Decisions Summary)

## 2026-01-17: review-010 completed

**Task**: Check Biome mutual exclusivity logic
**Check**: If Biome selected for linting, formatting question should be skipped. Is this clear in the flow?

**Finding**:
- The PLAN.md incompatibility rules correctly state "Biome | ESLint + Prettier | Pick one linting approach"
- The Linting/Formatting Compatibility table shows Biome is "Lint + Format" (all-in-one)
- However, there was NO explicit wizard flow documentation stating that selecting Biome should skip the formatting question
- Biome v2.x is now stable and production-ready (2025), offering 10-25x speed over ESLint+Prettier
- Biome has 97% Prettier compatibility and 200+ linting rules
- Single binary replaces 127+ npm packages (eslint, prettier, eslint-config-prettier, eslint-plugin-prettier, etc.)

**Action Required**: Added "Wizard Flow Logic: Linting & Formatting" section to PLAN.md documenting:
1. If user selects Biome for linting → skip formatting question (Biome handles both)
2. If user selects oxlint → show formatting question with oxfmt/Prettier options
3. If user selects ESLint → show formatting question with Prettier/oxfmt options
4. Implementation note: Logic goes in src/compatibility/filters.ts and src/prompts/tooling.ts

**Sources**:
- https://biomejs.dev/guides/migrate-eslint-prettier/
- https://medium.com/@pouria.r.1990/biome-js-the-unified-linter-and-formatter-replacing-eslint-and-prettier-2a752d8f357c
- https://betterstack.com/community/guides/scaling-nodejs/biome-eslint/
- https://dev.to/saswatapal/why-i-chose-biome-over-eslintprettier-20x-faster-linting-one-tool-to-rule-them-all-10kf

## 2026-01-17: review-011 completed

**Task**: Verify create-start CLI exists
**Check**: Plan says 'Wrap create-start' but TanStack Start CLI might have different name

**Finding**:
- The TanStack Start CLI EXISTS and is actively maintained
- Official package: `@tanstack/create-start` (v0.47.0 as of January 2026)
- Invocation: `npm create @tanstack/start@latest` or `pnpm create @tanstack/start@latest`
- Creates Vite-based applications with TanStack Router
- Supports multiple package managers: npm, yarn, pnpm, bun, deno
- Toolchain options: Biome or ESLint/Prettier
- Add-ons support: shadcn, tanstack-query, etc.
- MCP support for AI-assisted development
- The PLAN.md reference to 'create-start' was a shorthand - clarified to use actual npm create syntax

**Action Required**: Updated PLAN.md scaffolding table to clarify the exact command

**Sources**:
- https://www.npmjs.com/package/@tanstack/create-start
- https://tanstack.com/start/latest/docs/framework/react/quick-start
- https://github.com/TanStack/create-tsrouter-app/blob/main/cli/create-start-app/README.md

## 2026-01-17: review-012 completed

**Task**: Verify Remix scaffolder approach
**Check**: Should we use create-remix or React Router v7's scaffolder? They've merged

**Finding**:
- Remix has been MERGED into React Router v7 (announced December 2024, released December 2024)
- The official scaffolder is now `create-react-router` (v7.12.0 as of January 2026)
- Invocation: `npx create-react-router@latest my-app`
- React Router v7's "framework mode" includes all Remix features: loaders, actions, server rendering
- The `create-remix` package should NOT be used for new projects
- React Router v7 IS the successor to Remix v2 - same team, same philosophy
- Templates available via `--template remix-run/react-router-templates/<name>`
- Remix v3 exists as a separate React-less rewrite (Preact fork) but has no official docs and is not recommended

**Action Required**: Updated PLAN.md:
1. Changed scaffolding table from 'Wrap `create-remix`' to 'Wrap `create-react-router` (`npx create-react-router@latest`)'
2. Updated section title from 'Remix / React Router v7' to 'React Router v7 - Framework Mode'
3. Updated bundler from 'Vite (via Remix Vite plugin)' to 'Vite (built-in)'
4. Updated web frameworks references from 'Remix' to 'React Router v7'

**Sources**:
- https://reactrouter.com/upgrading/remix
- https://remix.run/blog/react-router-v7
- https://remix.run/blog/merging-remix-and-react-router
- https://www.npmjs.com/package/create-react-router
- https://reactrouter.com/start/framework/installation
- https://developers.cloudflare.com/workers/framework-guides/web-apps/react-router/

## 2026-01-17: review-013 completed

**Task**: Verify Astro scaffolder integration
**Check**: Does create astro support all the integrations we want to offer?

**Finding**:
- `create astro` (invoked via `npm create astro@latest`) DOES support all integrations we want to offer
- **Official integrations via `astro add`**:
  - UI frameworks: @astrojs/react, @astrojs/vue, @astrojs/svelte, @astrojs/solid-js, @astrojs/preact, @astrojs/alpinejs
  - Adapters: @astrojs/vercel, @astrojs/netlify, @astrojs/cloudflare, @astrojs/node
  - Other: @astrojs/db, @astrojs/mdx, @astrojs/markdoc, @astrojs/sitemap, @astrojs/partytown
- **Tailwind CSS**: Astro 5.2+ supports `astro add tailwind` which installs @tailwindcss/vite plugin for Tailwind v4 (the old @astrojs/tailwind is deprecated)
- **Auth providers**: Clerk (@clerk/astro) and better-auth require manual npm install but have full native Astro support with server-side middleware
- **ORMs**: Drizzle and Prisma require manual installation but work fully in Astro API routes
- **The `--add` flag** allows adding multiple integrations during creation: `npm create astro@latest -- --add react --add tailwind`
- All PLAN.md Astro requirements (styling, auth, ORM, deploy, testing) are achievable

**Action Required**: None - the PLAN.md correctly states 'Wrap `create astro`' and all desired integrations are supported

**Sources**:
- https://docs.astro.build/en/install-and-setup/
- https://docs.astro.build/en/guides/integrations-guide/
- https://docs.astro.build/en/guides/integrations-guide/react/
- https://tailwindcss.com/docs/guides/astro
- https://clerk.com/docs/quickstarts/astro
- https://docs.astro.build/en/guides/authentication/

## 2026-01-17: review-014 completed

**Task**: Verify Claude Code Docker image exists
**Check**: Plan references ghcr.io/anthropics/claude-code:latest - does this image exist?

**Finding**:
- There is NO official `ghcr.io/anthropics/claude-code:latest` Docker image
- Anthropic provides two official methods:
  1. **DevContainer feature**: `ghcr.io/anthropics/devcontainer-features/claude-code:1` for devcontainer.json
  2. **Reference Dockerfile**: In the claude-code repo using `node:20` base + `npm install -g @anthropic-ai/claude-code`
- Docker provides official support via `docker sandbox run claude` command
  - Uses `docker/sandbox-templates:claude-code` image
  - Automatic credential management (API key stored in persistent Docker volume)
  - Includes: Docker CLI, GitHub CLI, Node.js, Go, Python 3, Git, ripgrep, jq
- For bootstralph, three approaches are valid:
  1. **Docker Desktop users**: `docker sandbox run claude` (simplest)
  2. **Custom environments**: Generate Dockerfile using node:20 + npm install
  3. **VS Code users**: Generate devcontainer.json with claude-code feature

**Action Required**: Updated PLAN.md with comprehensive Docker Configuration section documenting all three approaches, including example configurations for each method.

**Sources**:
- https://github.com/anthropics/devcontainer-features
- https://github.com/anthropics/devcontainer-features/blob/main/src/claude-code/README.md
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://github.com/anthropics/claude-code/blob/main/.devcontainer/Dockerfile
- https://code.claude.com/docs/en/devcontainer

## 2026-01-17: review-015 completed

**Task**: Verify Docker compose syntax
**Check**: Is the docker-compose.yml syntax correct? Check volume mounts for API key

**Finding**:
- Docker's official `docker sandbox` approach uses CLI flags (`-e`, `-v`) not docker-compose.yml
- For custom Dockerfile approach, docker-compose.yml should use standard syntax:
  1. **Environment variables** via `environment:` section referencing .env files (`ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}`), never hardcoded
  2. **Volume mounts** with `volumes:` using `host-path:container-path` syntax (e.g., `.:/workspace`, `claude-config:/home/node/.claude`)
  3. **Named volumes** for persistence across container restarts
  4. For enhanced security, Docker secrets can be used
- Credentials persist in `docker-claude-sandbox-data` Docker volume mounted at `/mnt/claude-data`
- The PLAN.md correctly notes docker-compose.yml as a file to generate but lacked a template

**Action Required**: Added docker-compose.yml template to PLAN.md showing correct syntax with:
- Environment variable reference pattern (never hardcoding API keys)
- Volume mounts for workspace and .claude config
- Named volumes for persistence
- Security notes about .env files and Docker secrets

**Sources**:
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://docs.docker.com/ai/sandboxes/advanced-config/
- https://code.claude.com/docs/en/devcontainer
- https://github.com/RchGrav/claudebox
- https://gofranz.com/blog/automate-testing-with-docker-compose-and-claude-code/

## 2026-01-17: review-016 completed

**Task**: Verify network_mode: none security
**Check**: Commented out network isolation - should it be default? How does Ralph work without network?

**Finding**:
- `network_mode: none` is NOT viable for Claude Code
- Claude Code's core architecture requires network connectivity for:
  1. **API Communication**: Every Claude response requires calling `api.anthropic.com` - the AI doesn't run locally
  2. **Package Installation**: `npm install` needs `registry.npmjs.org`
  3. **Git Operations**: Cloning and pushing require `github.com`
- Required minimum domains for whitelisting:
  - `api.anthropic.com` - Core Claude API communication
  - `claude.ai` - Platform services
  - `registry.npmjs.org` - npm package installation
  - `github.com` - Repository access, cloning
- The correct approach is **domain whitelisting** using iptables-based filtering, not full network isolation
- This provides defense-in-depth (prevents data exfiltration to arbitrary servers) while maintaining functionality
- Anthropic's own sandboxing uses a proxy-based approach that restricts domains but doesn't fully isolate network

**Action Required**: Updated PLAN.md with comprehensive "Network Isolation Strategy" section including:
- Explanation of why `network_mode: none` doesn't work
- Required domains table
- iptables-based firewall script for domain whitelisting
- Security trade-offs comparison table
- Recommendation for domain whitelisting approach

**Sources**:
- https://code.claude.com/docs/en/sandboxing
- https://www.anthropic.com/engineering/claude-code-sandboxing
- https://docs.docker.com/ai/sandboxes/claude-code/
- https://mfyz.com/ai-coding-agent-sandbox-container/
- https://blog.arcade.dev/using-docker-sandboxes-with-claude-code

## 2026-01-17: review-017 completed

**Task**: Verify openskills programmatic API
**Check**: Plan uses execSync for openskills - is there a proper Node.js API?

**Finding**:
- openskills (v1.3.2 by numman-ali) is **CLI-only with NO programmatic Node.js API**
- The package.json has `main: './dist/cli.js'` with no `exports` field - it's designed as a command-line tool, not a library
- AI agents invoke it via shell commands (`openskills install`, `openskills sync`) rather than JavaScript imports
- This is the intended usage pattern - openskills treats skills as static markdown files and uses CLI invocation for universal compatibility across Claude Code, Cursor, Windsurf, Aider, and other AI agents
- OpenSkills uses a CLI-based approach rather than MCP to enable universal compatibility with any AI agent that has shell access
- The correct approach for bootstralph is using `execa` to spawn openskills CLI commands

**Action Required**: Updated PLAN.md Tech Stack section to clarify openskills is CLI-only (via execa), not a programmatic API. The implementation in src/ralph/skills.ts should use execa to run openskills commands.

**Sources**:
- https://github.com/numman-ali/openskills
- https://www.npmjs.com/package/openskills
- https://deepwiki.com/numman-ali/openskills/2-getting-started
- https://github.com/numman-ali/openskills/blob/main/package.json

## 2026-01-17: review-018 completed

**Task**: Verify all skill names are correct
**Check**: Check that skill names like 'supabase-operations' exist in marketplaces

**Finding**:
Most skill names in PLAN.md are correct but several needed corrections:

**VERIFIED EXISTING:**
- `planning-with-files` - ✅ EXISTS (OthmanAdi/planning-with-files)
- `react-best-practices` - ✅ EXISTS (vercel-labs/agent-skills)
- `vercel-deploy-claimable` - ✅ EXISTS (vercel-labs/agent-skills)
- `web-design-guidelines` - ✅ EXISTS (vercel-labs/agent-skills)
- `expo-app-design` - ✅ EXISTS (expo/skills)
- `expo-deployment` - ✅ EXISTS (expo/skills)
- `upgrading-expo` - ✅ EXISTS (expo/skills)
- `supabase-operations` - ✅ EXISTS (FastMCP marketplace)
- `better-auth` - ✅ EXISTS (@Microck/ordinary-claude-skills)
- `clerk-pack` - ✅ EXISTS (24 skills from claude-code-plugins-plus)
- `webapp-testing` - ✅ EXISTS (official anthropics/skills)
- `tailwind-v4-shadcn` - ✅ EXISTS (multiple sources)
- `docker-containerization` - ✅ EXISTS (multiple sources)
- `turborepo` - ✅ EXISTS (multiple sources)
- `monorepo-management` - ✅ EXISTS (wshobson/agents-plugins)
- Trail of Bits skills - ✅ EXISTS (trailofbits/skills: building-secure-contracts, burpsuite-project-parser)
- Drizzle skills - ✅ EXISTS (drizzle-orm-d1, drizzle, drizzle-migration)

**NOT FOUND / INCORRECT:**
- `superpowers` - NOT a skill name, it's the repo name (obra/superpowers). Actual skills are: test-driven-development, systematic-debugging, verification-before-completion, brainstorming, writing-plans, executing-plans, etc.
- `supabase-platform-specialist` - ❌ DOES NOT EXIST
- `stripe-integration` - ❌ NOT FOUND as specific skill
- `stripe-best-practices` - ❌ NOT FOUND as specific skill
- `vitest-testing-expert` - ❌ NOT FOUND (use `webapp-testing` instead)

**Action Required**: Updated PLAN.md Skills Installation Strategy table with corrected skill names and sources.

**Sources**:
- https://github.com/vercel-labs/agent-skills
- https://github.com/obra/superpowers
- https://github.com/expo/skills
- https://github.com/anthropics/skills/tree/main/skills
- https://github.com/OthmanAdi/planning-with-files
- https://fastmcp.me/Skills/Details/316/supabase-operations
- https://claudecodeplugins.io/skills/clerk-migration-deep-dive/
- https://claude-plugins.dev/skills/@Microck/ordinary-claude-skills/better-auth
- https://claude-plugins.dev/skills/@ovachiever/droid-tings/tailwind-v4-shadcn
- https://claude-plugins.dev/skills/@ailabs-393/ai-labs-claude-skills/docker-containerization
- https://claude-plugins.dev/skills/@timelessco/recollect/turborepo
- https://skillsmp.com/skills/wshobson-agents-plugins-developer-essentials-skills-monorepo-management-skill-md
- https://github.com/trailofbits/skills
- https://claude-plugins.dev/skills/@jezweb/claude-skills/drizzle-orm-d1

## 2026-01-17: review-019 completed

**Task**: Verify Drizzle patterns skill exists
**Check**: Plan says 'Drizzle patterns (community)' - is there an actual skill?

**Finding**:
YES, multiple Drizzle skills exist and are actively maintained:

1. **drizzle-orm-d1** (@jezweb/claude-skills)
   - Status: Production Ready, last updated January 9, 2026
   - Covers D1 database patterns including batch API for transactions, migrations, 12 common D1 errors
   - Package versions: drizzle-orm@0.45.1, drizzle-kit@0.31.8

2. **drizzle** (@korallis/Droidz)
   - General Drizzle ORM skill for schema definition, migrations, type-safe queries
   - Activates when users discuss Drizzle ORM, database schemas, or SQL queries

3. **drizzle-migration** (@Dexploarer/hyper-forge)
   - Guides proper migration workflow using Drizzle Kit
   - Covers schema modification, migration generation, rollback strategies
   - Emphasizes inspecting generated SQL before running db:migrate

4. **rr-drizzle** (@roderik/ai-rules)
   - Additional Drizzle patterns from ai-rules collection

The PLAN.md already correctly lists these as `drizzle-orm-d1, drizzle, drizzle-migration` (line 282).
This was also verified during review-018.

**Action Required**: None - the PLAN.md Skills Installation Strategy is already accurate

**Sources**:
- https://claude-plugins.dev/skills/@jezweb/claude-skills/drizzle-orm-d1
- https://claude-plugins.dev/skills/@korallis/Droidz/drizzle
- https://claude-plugins.dev/skills/@Dexploarer/hyper-forge/drizzle-migration
- https://mcpmarket.com/tools/skills/drizzle-orm-development
- https://skillsmp.com/skills/jezweb-claude-skills-skills-drizzle-orm-d1-skill-md

## 2026-01-17: review-020 completed

**Task**: Check SaaS preset completeness
**Check**: SaaS preset uses NativeWind but it's for mobile - should be Tailwind + shadcn

**Finding**:
- The review premise was INCORRECT - the PLAN.md never specified NativeWind for the SaaS preset
- The directory structure showed `saas.ts # Next.js + auth + payments` and all Next.js sections consistently specify `Tailwind + shadcn/ui` as the styling choice (lines 65, 78, 92)
- However, the PLAN.md lacked explicit preset configurations, which could cause confusion
- Verified via industry standards:
  - Vercel's official Next.js SaaS Starter uses Tailwind + shadcn/ui
  - ixartz/SaaS-Boilerplate uses Tailwind + shadcn/ui
  - Encore.ts SaaS Starter uses Tailwind + shadcn/ui
  - All major SaaS starters use Tailwind + shadcn/ui (NOT NativeWind)
- NativeWind is for mobile (Expo/React Native), not web projects

**Action Required**: Added explicit "Preset Configurations" section to PLAN.md documenting full configuration for each preset:
1. **SaaS Preset**: Next.js + Tailwind CSS + shadcn/ui + better-auth + Drizzle + Stripe + Vercel
2. **Mobile Preset**: Expo + Uniwind + Clerk + Supabase + EAS
3. **API Preset**: Hono + Drizzle + better-auth + Cloudflare Workers
4. **Fullstack Preset**: Turborepo + Next.js + Hono + Biome

The SaaS preset now explicitly shows `styling: Tailwind CSS + shadcn/ui` to prevent any future confusion.

**Sources**:
- https://vercel.com/templates/next.js/next-js-saas-starter
- https://github.com/ixartz/SaaS-Boilerplate
- https://encore.dev/templates/saas-starter
- https://www.shadcn.io/template/nextjs-saas-starter
- https://indie-starter.dev/blog/shadcn-templates

## 2026-01-17: review-021 completed

**Task**: Check Mobile preset styling
**Check**: Mobile preset uses NativeWind but Uniwind is now recommended

**Finding**:
- The review premise was INCORRECT - the PLAN.md already correctly specifies Uniwind as the recommended default for Mobile styling
- Verified in multiple locations:
  1. **Mobile Preset section** (line 407): `styling: Uniwind (recommended)`
  2. **Expo section** (line 106): `styling: Uniwind (recommended), NativeWind, Tamagui, Unistyles, StyleSheets`
  3. **React Native CLI section** (line 118): `styling: Uniwind (recommended), NativeWind, Tamagui, StyleSheets`
  4. **Key Decisions Summary** (line 460): `Mobile styling (default) | Uniwind | Fastest Tailwind for RN, from Unistyles creators`
- Uniwind (v1.2.4, January 2026) is production-ready and claims 2.5x faster performance than NativeWind
- Uniwind is a drop-in replacement for NativeWind with near-100% Tailwind compatibility
- NativeWind remains available as an alternative for teams already using it or preferring its larger ecosystem (gluestack UI, NativeWindUI)
- HeroUI Native has migrated to Uniwind, confirming production readiness

**Action Required**: None - the PLAN.md already correctly specifies Uniwind as the recommended Mobile styling default

**Sources**:
- https://uniwind.dev/
- https://www.reactnativecrossroads.com/posts/introducing-uniwind-the-fastest-tailwind-bindings-for-react-native/
- https://nativelaunch.dev/articles/uniwind
- https://github.com/efstathiosntonas/react-native-style-libraries-benchmark
- https://blog.logrocket.com/best-react-native-ui-component-libraries/

## 2026-01-17: review-022 completed

**Task**: Check Monorepo preset package manager
**Check**: Monorepo preset uses pnpm workspaces but bun is default - inconsistent?

**Finding**:
- The review premise was INCORRECT - the PLAN.md did NOT specify pnpm workspaces for the Monorepo preset
- The Fullstack/Monorepo Preset only specified `structure: Turborepo` without mentioning a specific package manager
- The Key Decisions Summary correctly states `bun` as the default package manager
- As of December 2025, Turborepo 2.6 moved Bun package manager support from beta to **STABLE**
- Turborepo 2.5 (October 2025) added Bun pruning support
- Bun workspaces work well with Turborepo using `workspaces: ["apps/*", "packages/*"]` in package.json
- Configuration requires `"packageManager": "bun@1.x.x"` in root package.json
- Key caveat: Use `--cwd` flag for workspace-specific installs (`bun add <pkg> --cwd apps/web`) instead of `--filter`
- Bun is approximately 4x faster than pnpm for clean installs in monorepos
- The PLAN.md is CONSISTENT - bun should be used for Turborepo monorepos

**Action Required**: Added explicit package manager specification (`package_manager: bun (with bun workspaces)`) to Fullstack/Monorepo Preset section. Added "Monorepo Package Manager Notes" subsection with usage details.

**Sources**:
- https://turborepo.dev/blog/turbo-2-6
- https://github.com/vercel/turborepo/discussions/7456
- https://www.fgbyte.com/blog/02-bun-turborepo-hell
- https://github.com/shadcn-ui/ui/discussions/6465
- https://dev.to/kirteshbansal/choosing-the-right-javascript-package-manager-in-2025-npm-vs-yarn-vs-pnpm-vs-bun-2jie
- https://betterstack.com/community/guides/scaling-nodejs/pnpm-vs-bun-install-vs-yarn/

## 2026-01-17: review-023 completed

**Task**: Verify better-auth Expo support
**Check**: Plan shows better-auth as API-only for Expo - is this the best approach?

**Finding**:
- The PLAN.md characterization of better-auth as "API only" for Expo was **INCORRECT**
- better-auth has an official `@better-auth/expo` package (v1.4.10) that provides full native mobile support:
  - **Native session management** via `expo-secure-store` (eliminates loading spinners on app reload)
  - **Deep linking integration** for OAuth flows with automatic scheme conversion
  - **Social auth** with native OAuth flows (Google, Apple, Facebook with ID token verification)
  - **useSession hook** with SecureStore caching for persistent sessions
  - Supports both Expo native and web apps
- Expo's official documentation lists better-auth among recommended authentication services alongside Clerk and Supabase
- TurboStarter offers an official "Expo + better-auth Mobile App Template" demonstrating production usage
- Both better-auth and Clerk now offer **equivalent native SDK support** for Expo

**Action Required**: Updated PLAN.md:
1. Changed Expo auth line from `Clerk (native support), better-auth (API)` to `Clerk (native SDK), better-auth (native SDK via @better-auth/expo)`
2. Updated Auth Provider Compatibility table to show better-auth as "Native" for both Expo and React Native columns

**Sources**:
- https://www.better-auth.com/docs/integrations/expo
- https://www.npmjs.com/package/@better-auth/expo
- https://docs.expo.dev/develop/authentication/
- https://www.turbostarter.dev/stacks/expo-better-auth-mobile-app-template
- https://labs.convex.dev/better-auth/framework-guides/expo

## 2026-01-17: review-024 completed

**Task**: Verify Supabase Auth as option
**Check**: Supabase Auth is in compatibility table but not in wizard options

**Finding**:
- The review premise was CORRECT - Supabase Auth was in the Auth Provider Compatibility table but NOT listed in the framework-specific wizard options
- Supabase Auth is a fully production-ready authentication solution:
  - **Next.js**: `@supabase/ssr` package provides SSR support with App Router, middleware integration, and cookie-based sessions
  - **TanStack Start**: Official quickstart available using supabase-js and @supabase/ssr (TanStack Start still in beta, integration working but expect changes)
  - **React Native/Expo**: Native support via `@supabase/supabase-js` with `@react-native-async-storage/async-storage` for session persistence
  - **Astro**: Works with API routes and server endpoints
- Supabase Auth offers the most generous free tier: 50,000 MAU compared to 10,000 MAU from competitors
- Row Level Security (RLS) integration provides database-level authorization impossible with other solutions
- Note: `@supabase/auth-helpers` package is deprecated - use `@supabase/ssr` instead

**Action Required**: Updated PLAN.md to add Supabase Auth to wizard options:
1. Next.js: `auth: better-auth, Clerk, Supabase Auth`
2. TanStack Start: `auth: better-auth, Clerk, Supabase Auth`
3. React Router v7: `auth: better-auth, Clerk, Supabase Auth`
4. Expo: `auth: Clerk (native SDK), better-auth (native SDK via @better-auth/expo), Supabase Auth (native via @supabase/supabase-js)`
5. React Native CLI: `auth: Clerk, better-auth, Supabase Auth`
6. Astro: `auth: better-auth, Clerk, Supabase Auth`

**Sources**:
- https://supabase.com/docs/guides/auth/quickstarts/react-native
- https://supabase.com/docs/guides/auth/quickstarts/nextjs
- https://supabase.com/docs/guides/auth/server-side/nextjs
- https://supabase.com/docs/guides/getting-started/quickstarts/tanstack
- https://tanstack.com/start/latest/docs/framework/react/examples/start-supabase-basic
- https://docs.expo.dev/guides/using-supabase/

## 2026-01-17: review-025 completed

**Task**: Verify Convex compatibility with all frameworks
**Check**: Convex is listed for Expo backend but is it compatible with Next.js/TanStack?

**Finding**:
Convex is compatible with ALL frameworks mentioned in PLAN.md, not just Expo:

1. **Next.js**: Full App Router support with server rendering (beta) via `convex/nextjs` helpers
   - `preloadQuery` for SSR with client-side reactivity
   - `fetchQuery`, `fetchMutation`, `fetchAction` for Server Components/Actions
   - Official demo app and quickstart available

2. **TanStack Start**: First-class integration via `@convex-dev/react-query`
   - Uses `@tanstack/react-router-with-query` for SSR
   - Live updates from Convex supercharge React Query
   - Hydrating Query Client makes SSR seamless
   - Official example: TanStack Start + Convex Trellaux

3. **React Router v7**: Works with standard Convex React client
   - Same React patterns, useQuery hook works as expected
   - React Router v7 is standard React so Convex React client is compatible

4. **Expo/React Native**: Official support, same React client as web
   - Official quickstart at docs.convex.dev/quickstart/react-native
   - Convex Auth (beta) supports both web and React Native
   - Universal apps possible with Expo + Tamagui + Convex

5. **Astro**: Official starter template available
   - Uses `withConvexProvider` wrapper for React islands
   - `useQuery` and Convex hooks work in client components as usual

The PLAN.md only listed Convex under Expo backend options, but it should be a backend option for ALL frameworks.

**Action Required**: Updated PLAN.md:
1. Added `backend: Convex (real-time), Supabase` to Next.js, TanStack Start, React Router v7, and Astro sections
2. Added notes explaining Convex integration specifics for each framework
3. Expanded Database/Backend Options table with "Reactive queries + type-safety" and "Full-stack type-safe backend" use cases
4. Added "Convex Framework Compatibility" section documenting support for each framework
5. Added `convex` skill to Skills by Stack table

**Sources**:
- https://docs.convex.dev/client/nextjs/app-router/
- https://docs.convex.dev/quickstart/nextjs
- https://docs.convex.dev/client/tanstack/tanstack-start/
- https://docs.convex.dev/quickstart/tanstack-start
- https://tanstack.com/start/latest/docs/framework/react/examples/start-convex-trellaux
- https://docs.convex.dev/quickstart/react-native
- https://docs.convex.dev/client/react-native
- https://www.convex.dev/can-do/mobile-apps
- https://www.convex.dev/templates/astro
- https://www.bitdoze.com/astro-convex-realtime-app/
- https://claude-plugins.dev/skills/@ThijmenGThN/next-leaflet/convex

## 2026-01-17: review-026 completed

**Task**: Verify Firebase option completeness
**Check**: Firebase is listed but no skills mentioned for it

**Finding**:
- Firebase IS listed in PLAN.md as a backend option for Expo (line 116) and in Database/Backend Options table as "NoSQL / Firebase-like"
- However, NO Firebase skill was listed in the Skills by Stack table
- Research found available Firebase-related tools:
  1. **firebase-functions-templates** skill EXISTS (@onesmartguy/next-level-real-estate)
     - Creates production-ready Firebase Cloud Functions with TypeScript
     - Includes Express integration, HTTP endpoints, background triggers, scheduled functions
     - Provides service layer patterns for Firestore operations
  2. **firebase-mcp** (gannonh/firebase-mcp) - MCP server (NOT a skill)
     - Supports Firestore operations (add, list, get, update, delete documents)
     - Storage file management (list, upload, retrieve URLs)
     - Authentication user lookup by ID or email
     - Installed via `npx @gannonh/firebase-mcp`
  3. NO comprehensive Firebase skill exists for general Firebase development patterns (Auth flows, Firestore security rules, real-time listeners)
- The official Claude plugins marketplace shows firebase/firebase-tools with 4,303 stars as "Official Claude plugin for Firebase"

**Action Required**: Updated PLAN.md:
1. Added Firebase row to Skills by Stack table with `firebase-functions-templates` skill
2. Added note that comprehensive Firebase skills are limited - recommend using `firebase-mcp` MCP server for Firestore/Auth operations

**Sources**:
- https://claude-plugins.dev/skills/@onesmartguy/next-level-real-estate/firebase-functions-templates
- https://github.com/gannonh/firebase-mcp
- https://claudemarketplaces.com/plugins/firebase-firebase-tools
- https://github.com/markhilton/mcp-firestore-server

## 2026-01-17: review-027 completed

**Task**: Verify EAS auto-selection
**Check**: Plan auto-selects EAS for Expo - should users have other options?

**Finding**:
YES, users should have other Expo deployment options beyond auto-selecting EAS. Valid alternatives exist:

1. **EAS Build (Cloud)** - Recommended default, no local Xcode/Android Studio required, automatic credential management
2. **Local Builds (`eas build --local`)** - Unlimited free builds using your own hardware, faster iteration, full control
3. **GitHub Actions + Fastlane** - Self-hosted CI/CD pipeline, can save $100s/month vs EAS paid tiers, full control over infrastructure
4. **Codemagic** - Third-party cloud CI/CD with pay-as-you-go pricing, CodePush support at $99/month per 100k MAU

Auto-selecting EAS ignores important use cases:
- **Cost concerns**: EAS free tier has limits (shared queue, monthly build caps), paid tiers start at $19/month
- **Company policies**: Some organizations restrict third-party CI/CD services
- **Self-hosted preference**: Teams wanting full control and reproducible builds
- **Local iteration**: `eas build --local` enables faster debugging without queue wait times

EAS Build should remain the recommended default (easiest path, great for most users) but alternatives should be offered in the wizard.

**Action Required**: Updated PLAN.md:
1. Changed Expo deploy line from `EAS (Expo Application Services)` to `EAS Build (recommended), Local Builds (eas build --local), GitHub Actions + Fastlane, Codemagic`
2. Added "Expo Deployment Options" subsection explaining each option
3. Updated Mobile Preset deploy line to show both cloud and local options

**Sources**:
- https://docs.expo.dev/build-reference/local-builds/
- https://docs.expo.dev/build/introduction/
- https://expo.dev/pricing
- https://github.com/TanayK07/expo-react-native-cicd
- https://docs.codemagic.io/yaml-quick-start/building-a-react-native-app/
- https://blog.logrocket.com/fastlane-build-test-ship-react-native-apps/
- https://iamkhushbajwa.medium.com/releasing-apps-without-expos-eas-builds-5017f304b6be

## 2026-01-17: review-028 completed

**Task**: Verify Railway compatibility
**Check**: Railway is listed for Next.js but not for TanStack Start in detailed section

**Finding**:
- The review premise was INCORRECT - Railway IS already listed for TanStack Start in PLAN.md
- Line 87 already shows: `deploy: Any (Vercel, Cloudflare, Fly.io, Railway)`
- Official TanStack Start documentation explicitly lists Railway as a supported deployment target under the Node.js category
- Railway has multiple community-created templates for TanStack Start:
  1. **TanStack Start Monorepo (Bun)** - Created Dec 2025, 100% success rate, includes Better Auth + Drizzle + Supabase
  2. **TanStack Start - Drizzle** - Created Mar 2025, simple starter with TanStack Query
  3. **TanStack Shopify App Template** - Created Nov 2025, full Shopify app boilerplate
- TanStack Start uses Nitro as its server runtime which supports the `node-server` preset that works natively with Railway
- **Bun deployment caveat**: When using Bun, users must configure `preset: 'bun'` in app.config.ts (not `node-server`) and start with `bun run .output/server/index.mjs`

**Action Required**: None - the PLAN.md already correctly lists Railway as a deployment option for TanStack Start

**Sources**:
- https://tanstack.com/start/latest/docs/framework/react/guide/hosting
- https://railway.com/deploy/tanstack-start-mon-1
- https://railway.com/deploy/nAdb0P
- https://railway.com/deploy/tanstack-shopify-app-template
- https://station.railway.com/questions/tanstack-start-works-locally-but-not-dep-1b8e915a
- https://nitro.build/deploy

## 2026-01-17: review-029 completed

**Task**: Verify Vitest 4 compatibility
**Check**: Plan uses vitest ^4.0.0 - is v4 released and stable?

**Finding**:
- Vitest 4.0 IS released and production-ready
- Released October 22, 2025, current version v4.0.17 (January 12, 2026)
- Key features in v4.0:
  1. **Browser Mode graduated to stable** - No longer experimental, with separate provider packages for Playwright, WebdriverIO, Preview
  2. **Built-in visual regression testing** - New `toMatchScreenshot` assertion for UI component comparison
  3. **Playwright Traces integration** - Generates browser traces for debugging
  4. **Enhanced Locators** - Adds `frameLocator` API and `length` property on locators
  5. **Improved Debugging** - VSCode extension supports "Debug Test" buttons for browser tests
  6. **New Matchers** - `expect.schemaMatching` for schema validation, `toBeInViewport` for visibility checks
- Maintained by VoidZero (same team behind Vite, oxc, Rolldown)
- Active development: v4.1.0-beta.1 already available (January 14, 2026)
- Breaking changes exist - migration guide available at vitest.dev

**Action Required**: None - the PLAN.md recommendation of Vitest for web unit testing is correct and v4.x is stable for production use

**Sources**:
- https://vitest.dev/blog/vitest-4
- https://voidzero.dev/posts/announcing-vitest-4
- https://github.com/vitest-dev/vitest/releases
- https://www.infoq.com/news/2025/12/vitest-4-browser-mode/

## 2026-01-17: review-030 completed

**Task**: Verify Jest + oxlint combination
**Check**: Does oxlint work well with Jest for React Native projects?

**Finding**:
- YES, oxlint works well with Jest for React Native projects
- Oxlint 1.0 stable (June 2025) includes a **native Jest plugin** with 29 Jest-specific rules built in Rust:
  - Test organization: `consistent-test-it`, `max-nested-describe`, `require-top-level-describe`
  - Assertions: `expect-expect`, `max-expects`, `valid-expect`
  - Test structure: `no-disabled-tests`, `no-focused-tests`, `no-conditional-in-test`
  - And 20+ more rules covering mocking, hooks, matchers, snapshots
- **Enable Jest plugin**: Via `--jest-plugin` CLI flag or `"plugins": ["jest"]` in `.oxlintrc.json`
- **Real-world validation**: OneSignal's `react-native-onesignal` library uses oxlint with Jest configuration in production
- **Performance**: Oxlint is 50-100x faster than ESLint with native Jest rules

**CAVEAT - eslint-plugin-react-native**:
- `eslint-plugin-react-native` is NOT natively supported in oxlint
- Workarounds:
  1. Use experimental `jsPlugins` feature: `"jsPlugins": ["eslint-plugin-react-native"]`
  2. Run both linters: `oxlint && eslint` (recommended) - oxlint handles Jest/TS/React fast, ESLint handles RN-specific rules
- The `eslint-plugin-oxlint` package provides `'flat/jest'` config to disable ESLint rules already covered by oxlint, avoiding duplicate warnings

**Recommended Configuration for React Native + Jest**:
```json
// .oxlintrc.json
{
  "plugins": ["jest", "react", "typescript"],
  "rules": {
    "jest/no-focused-tests": "error",
    "jest/no-disabled-tests": "warn"
  }
}
```

**Action Required**: None - the PLAN.md correctly shows Jest for React Native testing and oxlint as the default linter. The combination works well with the native Jest plugin.

**Sources**:
- https://voidzero.dev/posts/announcing-oxlint-1-stable
- https://oxc.rs/docs/guide/usage/linter/plugins
- https://github.com/OneSignal/react-native-onesignal/blob/main/.oxlintrc.json
- https://github.com/oxc-project/eslint-plugin-oxlint
- https://betterstack.com/community/guides/scaling-nodejs/oxlint-explained/

## 2026-01-17: review-031 completed

**Task**: Verify prek stability and adoption
**Check**: Is prek production-ready? Check v0.2.x stability, adoption by Apache Airflow, FastAPI

**Finding**:
- prek IS production-ready for most use cases
- Current version: v0.2.29 (January 16, 2026)
- **Apache Airflow**: Switched to prek in August 2025 (PR #54726 merged by Jarek Potiuk), now using v0.2.12 in production
- **FastAPI**: Switched in December 2025 (PR #14572 by tiangolo merged December 19, 2025), also rolled out to Typer, SQLModel, and other FastAPI ecosystem projects

**Supported Languages**:
- Python (uses uv for virtualenvs)
- Node.js
- Go
- Rust
- Ruby (uses system Ruby, version managers like rvm/rbenv/mise/asdf)
- Lua (via LuaRocks)
- Docker / Docker Image
- System, Script, Pygrep, Fail

**NOT Supported** (yet):
- Conda, Coursier, Dart, Dotnet, Haskell, Julia, Perl, R, Swift
- Deno (experimental/in progress)

**Missing Subcommands**:
- Only `gc` (garbage collection) is not implemented

**Key Advantages**:
- 10x faster than pre-commit
- Uses only 1/3 of disk space
- Built-in monorepo/workspace support
- Parallel hook execution by priority
- Uses uv for Python virtualenvs (faster installs)
- Fully compatible with existing .pre-commit-config.yaml files
- Single binary with no dependencies (doesn't require Python runtime)

**Action Required**: None - prek is production-ready and actively used by major projects. The PLAN.md should consider prek as a valid pre-commit hook option alongside Lefthook and Husky, especially for projects already using Python-based pre-commit hooks.

**Sources**:
- https://github.com/j178/prek
- https://prek.j178.dev/
- https://prek.j178.dev/languages/
- https://github.com/apache/airflow/pull/54258
- https://lists.apache.org/thread/dzs4s8wr8jd7q5r3lvcov2nhqpgt1031
- https://github.com/fastapi/fastapi/pull/14572
- https://hugovk.dev/blog/2025/ready-prek-go/

