{
  "name": "bootstralph",
  "version": "0.1.0",
  "description": "CLI for scaffolding Ralph-powered projects with intelligent skill installation and compatibility-aware option selection",
  "status": "planning",
  "specs": {
    "core_philosophy": {
      "docker_first": "Claude Code MUST always run in Docker sandbox",
      "interactive_claude": "No direct API calls - guide users to interactive Claude in container",
      "easy_setup": "Make container instantiation as frictionless as possible"
    }
  },
  "workflow": {
    "instructions": [
      "Work through review_tasks BEFORE starting implementation_tasks",
      "Update task status to 'in_progress' when starting, 'completed' or 'failed' when done",
      "Add 'finding' field to review tasks with what you discovered",
      "If a review task reveals an issue, add 'action_required' field describing the fix needed",
      "After completing review tasks, update PLAN.md to reflect any necessary changes",
      "Only proceed to implementation_tasks once all critical review issues are resolved"
    ],
    "status_values": [
      "pending",
      "in_progress",
      "completed",
      "failed",
      "blocked"
    ],
    "example_completed_review": {
      "id": "review-XXX",
      "category": "example",
      "task": "Verify something works",
      "check": "Does X work with Y?",
      "status": "completed",
      "finding": "X works with Y as of v2.0, confirmed via official docs",
      "action_required": null
    },
    "example_failed_review": {
      "id": "review-YYY",
      "category": "example",
      "task": "Verify something else",
      "check": "Is Z stable?",
      "status": "failed",
      "finding": "Z is deprecated, replaced by W in January 2025",
      "action_required": "Update PLAN.md to use W instead of Z"
    }
  },
  "review_tasks": [
    {
      "id": "review-001",
      "category": "compatibility-matrix",
      "task": "Verify Next.js incompatibility rules are complete",
      "check": "Can Next.js actually use React Router? Are there edge cases where TanStack Router works with Next.js?",
      "status": "completed",
      "finding": "React Router CAN technically be used in Next.js but loses SSR/SEO benefits and is not recommended. TanStack Router conflicts with Next.js History API - workarounds exist (memory history, route groups, patching) but you lose SSR benefits. The incompatibility rules in PLAN.md are correct: Next.js should not use TanStack Router or React Router as primary routing.",
      "action_required": null
    },
    {
      "id": "review-002",
      "category": "compatibility-matrix",
      "task": "Verify TanStack Start + RSC compatibility status",
      "check": "Is RSC support still 'coming soon' or has it shipped? Check TanStack changelog",
      "status": "completed",
      "finding": "RSC support is still 'coming soon' as of January 2026. TanStack Start v1 is in Release Candidate stage. Official docs state 'we are actively working on integration and expect to support them in the near future.' RSC will land as a non-breaking v1.x addition. The PLAN.md statement 'rsc: Not yet supported (coming soon)' is accurate.",
      "action_required": null
    },
    {
      "id": "review-003",
      "category": "compatibility-matrix",
      "task": "Verify Expo + Vitest incompatibility",
      "check": "Is vitest-react-native mature enough now? Check latest status",
      "status": "completed",
      "finding": "vitest-react-native is NOT mature enough. The package is still WIP/experimental (v0.1.5, no official releases), has only 76 GitHub stars and 5 forks, and explicitly warns it's 'not production-ready'. Community feedback reports it's 'not very reliable' with testing-library functions, and Expo+Vitest combination is described as 'an endless pit of issues'. Jest remains the required/recommended choice for React Native and Expo unit testing.",
      "action_required": null
    },
    {
      "id": "review-004",
      "category": "compatibility-matrix",
      "task": "Verify Uniwind stability",
      "check": "Is Uniwind production-ready or still in beta? Check release status",
      "status": "completed",
      "finding": "Uniwind IS production-ready. Both free and Pro versions are explicitly stated as 'production-ready and actively maintained' in official docs. Current version is v1.2.4 (Jan 2026), with 1.2k GitHub stars and 21 releases. Repository created July 2025, now stable. Offers 2x performance over NativeWind. HeroUI Native has migrated to Uniwind. The recommendation of Uniwind as default mobile styling in PLAN.md is appropriate.",
      "action_required": null
    },
    {
      "id": "review-005",
      "category": "compatibility-matrix",
      "task": "Verify oxfmt alpha stability",
      "check": "oxfmt is listed as alpha - is it stable enough for default recommendation?",
      "status": "completed",
      "finding": "Oxfmt is in alpha (announced Dec 1, 2025) with beta ETA Q1 2026. Currently at v0.24.0 with active weekly releases. Passes 95% of Prettier's JS/TS tests, 30x faster than Prettier. While alpha, it's professionally maintained by VoidZero/Oxc team with frequent bug fixes and real-world usage. SST's opencode has added experimental oxfmt support. For a CLI scaffolder targeting developers who want cutting-edge tools, oxfmt is a reasonable default with Prettier as fallback option. The PLAN.md correctly notes it as 'Alpha, 95%+ Prettier compatible'.",
      "action_required": "Consider adding Prettier as explicit fallback option in wizard for users who need 100% stability. The current PLAN.md recommendation is acceptable for the target audience."
    },
    {
      "id": "review-006",
      "category": "wizard-flow",
      "task": "Check Universal platform flow logic",
      "check": "If user selects Universal, we auto-select Expo + Tamagui. But should we ask about styling?",
      "status": "completed",
      "finding": "The wizard SHOULD ask about styling for Universal platform, not auto-select Tamagui. While Tamagui is the best option for true universal apps (75k weekly downloads, optimizing compiler), NativeWind (403k downloads) and Gluestack UI are valid alternatives. Teams already using Tailwind may prefer NativeWind. Gluestack UI v3 combines NativeWind + accessible components. Auto-selecting Tamagui ignores these valid use cases and Tamagui's steeper learning curve.",
      "action_required": "Update PLAN.md: For Universal platform, ask styling question with options: 1) Tamagui (Recommended) - best performance, comprehensive design system, 2) NativeWind - familiar Tailwind approach, larger community, 3) Gluestack UI - NativeWind + accessible components. Also update wizard flow description to show styling is NOT auto-selected for Universal."
    },
    {
      "id": "review-007",
      "category": "wizard-flow",
      "task": "Check Astro + Auth flow",
      "check": "Astro uses React islands for auth - is the UX clear that auth only works in islands?",
      "status": "completed",
      "finding": "The premise of this review was INCORRECT. Astro authentication does NOT only work in React islands. Both Clerk (@clerk/astro) and better-auth have native Astro integrations with server-side middleware, route protection, and Astro components. React islands are optional for interactive UI only. The current PLAN.md line 'auth: better-auth, Clerk (via React islands)' is misleading - both providers work server-side without requiring React.",
      "action_required": "Update PLAN.md Astro section: Change 'auth: better-auth, Clerk (via React islands)' to 'auth: better-auth, Clerk (native Astro SDKs available)'. Remove misleading 'via React islands' since both providers have first-class server-side Astro support."
    },
    {
      "id": "review-008",
      "category": "wizard-flow",
      "task": "Check feature selection order",
      "check": "Features are selected before deployment. Should deployment affect available features (e.g., edge functions)?",
      "status": "completed",
      "finding": "The current flow (features before deployment) is CORRECT, but post-selection validation is needed. Edge runtimes have significant limitations: Cloudflare Workers (V8 isolates, 3MB limit, TCP restrictions), Vercel Edge (limited Node.js APIs), Netlify Edge (Deno-based). Key incompatibilities: Prisma requires Accelerate/Prisma Postgres for edge (bundle too large, TCP issues), Drizzle needs edge-specific drivers (@libsql/client, Neon serverless, PlanetScale serverless). Most features work on most platforms, so asking deployment first adds unnecessary cognitive overhead. Better UX: validate after deployment selection and warn about incompatibilities with suggested alternatives.",
      "action_required": "Add post-deployment validation step to wizard that checks for edge runtime incompatibilities. When user selects Cloudflare/Vercel Edge/Netlify Edge AND Prisma, warn that Prisma Accelerate is required OR suggest Drizzle with edge-compatible driver. Add this validation logic to src/compatibility/validators.ts."
    },
    {
      "id": "review-009",
      "category": "wizard-flow",
      "task": "Check mobile E2E testing in recommended toolset",
      "check": "Recommended toolset says 'Playwright/Maestro' but should show only Maestro for mobile",
      "status": "completed",
      "finding": "The PLAN.md is ALREADY CORRECT. E2E testing recommendations are clearly platform-specific: (1) Key Decisions table shows 'Playwright (web), Maestro (mobile)' with explicit platform separation, (2) E2E Testing Compatibility matrix (lines 214-219) shows Playwright with ✅ for Web and ❌ for Expo/RN, Maestro with ❌ for Web and ✅ for Expo/RN, (3) Expo section (line 111) shows 'Jest (unit), Maestro (e2e, recommended), Detox' - only mobile tools, (4) Incompatibility Rules explicitly state 'Expo | Playwright/Cypress | Use Maestro/Detox instead'. There is no combined 'Playwright/Maestro' recommendation - the review task premise was incorrect.",
      "action_required": null
    },
    {
      "id": "review-010",
      "category": "wizard-flow",
      "task": "Check Biome mutual exclusivity logic",
      "check": "If Biome selected for linting, formatting question should be skipped. Is this clear in the flow?",
      "status": "completed",
      "finding": "The PLAN.md incompatibility rules correctly state 'Biome | ESLint + Prettier | Pick one linting approach' and the Linting/Formatting Compatibility table shows Biome is 'Lint + Format' (all-in-one). However, there is NO explicit wizard flow documentation stating that selecting Biome should skip the formatting question. The wizard prompts directory structure exists (src/prompts/) but the actual flow logic is not documented. Biome v2.x is now stable and production-ready, offering 10-25x speed over ESLint+Prettier with 97% Prettier compatibility and 200+ linting rules.",
      "action_required": "Add 'Wizard Flow Logic' section to PLAN.md documenting: (1) If user selects Biome for linting, skip the formatting question entirely since Biome handles both. (2) If user selects oxlint, show formatting question with oxfmt/Prettier options. (3) If user selects ESLint, show formatting question with Prettier/oxfmt options. This mutual exclusivity should be implemented in src/compatibility/filters.ts."
    },
    {
      "id": "review-011",
      "category": "scaffolders",
      "task": "Verify create-start CLI exists",
      "check": "Plan says 'Wrap create-start' but TanStack Start CLI might have different name",
      "status": "completed",
      "finding": "The TanStack Start CLI EXISTS and is actively maintained. The official package is `@tanstack/create-start` (v0.47.0 as of January 2026). It's invoked via `npm create @tanstack/start@latest` or `pnpm create @tanstack/start@latest`. The CLI creates Vite-based applications with TanStack Router and supports: multiple package managers (npm, yarn, pnpm, bun, deno), toolchain options (Biome or ESLint/Prettier), add-ons (shadcn, tanstack-query), and MCP support for AI-assisted development. The PLAN.md reference to 'create-start' is technically a shorthand - the actual invocation uses npm/pnpm create syntax rather than a standalone 'create-start' command.",
      "action_required": "Update PLAN.md scaffolding table: Change 'Wrap `create-start` (TanStack CLI)' to 'Wrap `@tanstack/create-start` via `npm create @tanstack/start@latest`' for clarity."
    },
    {
      "id": "review-012",
      "category": "scaffolders",
      "task": "Verify Remix scaffolder approach",
      "check": "Should we use create-remix or React Router v7's scaffolder? They've merged",
      "status": "completed",
      "finding": "Remix has been MERGED into React Router v7 (announced December 2024). The official scaffolder is now `create-react-router` (v7.12.0 as of January 2026), invoked via `npx create-react-router@latest`. This creates a Vite-based project with React Router v7's 'framework mode' which includes all Remix features (loaders, actions, server rendering). The `create-remix` package should NOT be used for new projects - React Router v7 IS the successor to Remix v2. Templates available via `--template remix-run/react-router-templates/<name>`. Remix v3 exists as a separate React-less rewrite (Preact fork) but has no official docs and is not recommended for production.",
      "action_required": "Update PLAN.md: (1) Change scaffolding table from 'Wrap `create-remix`' to 'Wrap `create-react-router` (`npx create-react-router@latest`)'. (2) Update section title from 'Remix / React Router v7' to 'React Router v7 (Framework Mode)' to reflect the official naming. (3) Update bundler from 'Vite (via Remix Vite plugin)' to 'Vite (built-in)'."
    },
    {
      "id": "review-013",
      "category": "scaffolders",
      "task": "Verify Astro scaffolder integration",
      "check": "Does create astro support all the integrations we want to offer?",
      "status": "completed",
      "finding": "create astro (npm create astro@latest) DOES support all integrations we want to offer. Official integrations via 'astro add': UI frameworks (React, Vue, Svelte, Solid, Preact, Alpine), adapters (Vercel, Netlify, Cloudflare, Node), and others (MDX, sitemap, partytown). Tailwind v4 supported via 'astro add tailwind' which installs @tailwindcss/vite plugin (Astro 5.2+). Auth (Clerk @clerk/astro, better-auth) and ORMs (Drizzle, Prisma) require manual npm install but work fully in Astro API routes. The '--add' flag allows adding multiple integrations during creation: 'npm create astro@latest -- --add react --add tailwind'. All PLAN.md Astro requirements are achievable.",
      "action_required": null
    },
    {
      "id": "review-014",
      "category": "docker",
      "task": "Verify Claude Code Docker image exists",
      "check": "Plan references ghcr.io/anthropics/claude-code:latest - does this image exist?",
      "status": "completed",
      "finding": "There is NO official `ghcr.io/anthropics/claude-code:latest` Docker image. Anthropic provides: (1) DevContainer feature at `ghcr.io/anthropics/devcontainer-features/claude-code:1` for devcontainer.json, (2) Reference Dockerfile in the claude-code repo using `node:20` + `npm install -g @anthropic-ai/claude-code`. Docker provides official support via `docker sandbox run claude` command which uses `docker/sandbox-templates:claude-code` image with automatic credential management. For bootstralph, we should use either the `docker sandbox` approach (simplest for Docker Desktop users) or generate a Dockerfile based on Anthropic's reference implementation.",
      "action_required": "Update PLAN.md to document correct Docker approaches: (1) Primary: `docker sandbox run claude` for Docker Desktop users, (2) Alternative: Generate Dockerfile using node:20 base + npm install @anthropic-ai/claude-code, (3) DevContainer: For VS Code users with devcontainer.json. Remove any references to non-existent ghcr.io/anthropics/claude-code image."
    },
    {
      "id": "review-015",
      "category": "docker",
      "task": "Verify Docker compose syntax",
      "check": "Is the docker-compose.yml syntax correct? Check volume mounts for API key",
      "status": "completed",
      "finding": "Docker's official 'docker sandbox' approach uses CLI flags (-e, -v) not docker-compose.yml. For custom Dockerfile approach, docker-compose.yml should use standard syntax: (1) Environment variables via 'environment:' section referencing .env files (ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}), never hardcoded. (2) Volume mounts with 'volumes:' using 'host-path:container-path' syntax (e.g., '.:/workspace', 'claude-config:/home/user/.claude'). (3) For enhanced security, Docker secrets can be used. (4) Credentials persist in 'docker-claude-sandbox-data' Docker volume mounted at /mnt/claude-data. The PLAN.md correctly notes docker-compose.yml as a file to generate but doesn't include a template - one should be added to src/templates/docker-compose.yml.ts following these patterns.",
      "action_required": "Add docker-compose.yml template to PLAN.md showing correct syntax for custom Dockerfile approach with: (1) Environment variable reference pattern, (2) Volume mounts for workspace and .claude config, (3) Named volumes for persistence. Template should NOT hardcode API keys."
    },
    {
      "id": "review-016",
      "category": "docker",
      "task": "Verify network_mode: none security",
      "check": "Commented out network isolation - should it be default? How does Ralph work without network?",
      "status": "completed",
      "finding": "`network_mode: none` is NOT viable for Claude Code. Claude Code requires network access for: (1) API communication - every Claude response requires calling api.anthropic.com (the AI doesn't run locally), (2) Package installation - npm install needs registry.npmjs.org, (3) Git operations - cloning and pushing require github.com. The correct approach is domain whitelisting using iptables-based filtering, not full network isolation. This provides defense-in-depth (prevents data exfiltration to arbitrary servers) while maintaining functionality. Required minimum domains: api.anthropic.com, claude.ai, registry.npmjs.org, github.com.",
      "action_required": "Updated PLAN.md with comprehensive 'Network Isolation Strategy' section explaining why network_mode: none doesn't work, documenting required domains, providing iptables-based firewall script for domain whitelisting, and comparing security trade-offs between approaches."
    },
    {
      "id": "review-017",
      "category": "skills",
      "task": "Verify openskills programmatic API",
      "check": "Plan uses execSync for openskills - is there a proper Node.js API?",
      "status": "completed",
      "finding": "openskills (v1.3.2) is CLI-only with NO programmatic Node.js API. The package.json has main: './dist/cli.js' with no exports field - it's designed as a command-line tool, not a library. AI agents invoke it via shell commands (openskills install, openskills sync) rather than JavaScript imports. For bootstralph, the correct approach is using execa to spawn openskills CLI commands. This is the intended usage pattern - openskills treats skills as static markdown files and uses CLI invocation for universal compatibility across Claude Code, Cursor, Windsurf, Aider, and other AI agents.",
      "action_required": "Updated PLAN.md Tech Stack section to clarify openskills is CLI-only (via execa), not a programmatic API. The implementation in src/ralph/skills.ts should use execa to run openskills commands."
    },
    {
      "id": "review-018",
      "category": "skills",
      "task": "Verify all skill names are correct",
      "check": "Check that skill names like 'supabase-operations' exist in marketplaces",
      "status": "completed",
      "finding": "Most skill names in PLAN.md are correct but several need corrections. VERIFIED EXISTING: planning-with-files (OthmanAdi/planning-with-files), react-best-practices (vercel-labs/agent-skills), vercel-deploy-claimable (vercel-labs/agent-skills), web-design-guidelines (vercel-labs/agent-skills), expo-app-design (expo/skills), expo-deployment (expo/skills), upgrading-expo (expo/skills), supabase-operations (FastMCP marketplace), better-auth (@Microck/ordinary-claude-skills), clerk-pack (24 skills from claude-code-plugins-plus), webapp-testing (official anthropics/skills), tailwind-v4-shadcn (multiple sources), docker-containerization (multiple sources), turborepo (multiple sources), monorepo-management (wshobson/agents-plugins), Trail of Bits skills (trailofbits/skills). NOT FOUND: 'superpowers' is not a skill name - it's the repo name (obra/superpowers) containing skills like test-driven-development, systematic-debugging, etc. 'supabase-platform-specialist' does not exist. 'stripe-integration' and 'stripe-best-practices' not found as specific skills. 'vitest-testing-expert' not found (use 'webapp-testing' instead). Drizzle skills exist as: drizzle-orm-d1, drizzle, drizzle-migration.",
      "action_required": "Update PLAN.md Skills Installation Strategy table: (1) Change 'superpowers (TDD, debugging)' to 'obra/superpowers skills: test-driven-development, systematic-debugging, verification-before-completion'. (2) Remove 'supabase-platform-specialist' (doesn't exist). (3) Change 'stripe-integration, stripe-best-practices' to note that Stripe skills need to be sourced from community repos or created custom. (4) Change 'vitest-testing-expert' to 'webapp-testing' (official). (5) Change 'Drizzle patterns (community)' to 'Drizzle skills: drizzle-orm-d1, drizzle, drizzle-migration'."
    },
    {
      "id": "review-019",
      "category": "skills",
      "task": "Verify Drizzle patterns skill exists",
      "check": "Plan says 'Drizzle patterns (community)' - is there an actual skill?",
      "status": "completed",
      "finding": "YES, multiple Drizzle skills exist and are actively maintained: (1) drizzle-orm-d1 by @jezweb/claude-skills - Production Ready, last updated Jan 9 2026, covers D1 database patterns including batch API, migrations, common errors. (2) drizzle by @korallis/Droidz - General Drizzle ORM skill for schema definition, migrations, type-safe queries. (3) drizzle-migration by @Dexploarer/hyper-forge - Guides proper migration workflow using Drizzle Kit. (4) rr-drizzle by @roderik/ai-rules - Additional Drizzle patterns. The PLAN.md already correctly lists these as 'drizzle-orm-d1, drizzle, drizzle-migration' (line 282). Review-018 also verified these skills exist.",
      "action_required": null
    },
    {
      "id": "review-020",
      "category": "presets",
      "task": "Check SaaS preset completeness",
      "check": "SaaS preset uses NativeWind but it's for mobile - should be Tailwind + shadcn",
      "status": "completed",
      "finding": "The review premise was INCORRECT. The PLAN.md never specified NativeWind for the SaaS preset. The directory structure showed 'saas.ts # Next.js + auth + payments' and all Next.js sections consistently specify 'Tailwind + shadcn/ui' as the styling choice. However, the PLAN.md lacked explicit preset configurations, which could cause confusion. Verified via Vercel's official Next.js SaaS Starter, ixartz/SaaS-Boilerplate, and other popular SaaS starters - all use Tailwind + shadcn/ui for styling (not NativeWind, which is for mobile).",
      "action_required": "Added explicit 'Preset Configurations' section to PLAN.md documenting full configuration for each preset (SaaS, Mobile, API, Fullstack). SaaS preset explicitly shows 'styling: Tailwind CSS + shadcn/ui' to prevent any future confusion."
    },
    {
      "id": "review-021",
      "category": "presets",
      "task": "Check Mobile preset styling",
      "check": "Mobile preset uses NativeWind but Uniwind is now recommended",
      "status": "completed",
      "finding": "The review premise was INCORRECT. The PLAN.md already correctly specifies Uniwind as the recommended default for Mobile styling, NOT NativeWind. Verified locations: (1) Mobile Preset section shows 'styling: Uniwind (recommended)', (2) Expo section shows 'styling: Uniwind (recommended), NativeWind, Tamagui, Unistyles, StyleSheets', (3) React Native CLI section shows 'styling: Uniwind (recommended), NativeWind, Tamagui, StyleSheets', (4) Key Decisions Summary shows 'Mobile styling (default) | Uniwind | Fastest Tailwind for RN, from Unistyles creators'. Uniwind (v1.2.4, Jan 2026) is production-ready, 2.5x faster than NativeWind, and is a drop-in replacement. NativeWind remains available as an alternative for teams already using it.",
      "action_required": null
    },
    {
      "id": "review-022",
      "category": "presets",
      "task": "Check Monorepo preset package manager",
      "check": "Monorepo preset uses pnpm workspaces but bun is default - inconsistent?",
      "status": "completed",
      "finding": "The review premise was INCORRECT - the PLAN.md does NOT specify pnpm workspaces for the Monorepo preset. The Fullstack/Monorepo Preset (lines 430-447) only specifies 'structure: Turborepo' without mentioning a specific package manager. The Key Decisions Summary (line 466) correctly states 'bun' as the default package manager. As of December 2025, Turborepo 2.6 moved Bun package manager support from beta to STABLE. Turborepo 2.5 (October 2025) added Bun pruning support. Bun workspaces work well with Turborepo using `workspaces: ['apps/*', 'packages/*']` in package.json with `packageManager: 'bun@1.x.x'`. The only caveat is using `--cwd` flag instead of `--filter` for workspace-specific installs. Bun is ~4x faster than pnpm for clean installs in monorepos. The PLAN.md is CONSISTENT - bun should be used for Turborepo monorepos.",
      "action_required": "Add explicit package manager specification to Fullstack/Monorepo Preset section in PLAN.md to clarify that bun workspaces are used with Turborepo (not pnpm). Add note about using `--cwd` flag for workspace installs."
    },
    {
      "id": "review-023",
      "category": "auth",
      "task": "Verify better-auth Expo support",
      "check": "Plan shows better-auth as API-only for Expo - is this the best approach?",
      "status": "completed",
      "finding": "The PLAN.md characterization of better-auth as 'API only' for Expo was INCORRECT. better-auth has an official @better-auth/expo package (v1.4.10) that provides full native mobile support: native session management via expo-secure-store (eliminates loading spinners on reload), deep linking integration for OAuth flows, social auth with native OAuth (Google, Apple, Facebook with ID token verification), useSession hook with SecureStore caching. Expo's official documentation lists better-auth among recommended authentication services alongside Clerk and Supabase. Both better-auth and Clerk now offer equivalent native SDK support for Expo.",
      "action_required": "Updated PLAN.md: (1) Changed Expo auth line from 'Clerk (native support), better-auth (API)' to 'Clerk (native SDK), better-auth (native SDK via @better-auth/expo)'. (2) Updated Auth Provider Compatibility table to show better-auth as 'Native' for both Expo and React Native columns."
    },
    {
      "id": "review-024",
      "category": "auth",
      "task": "Verify Supabase Auth as option",
      "check": "Supabase Auth is in compatibility table but not in wizard options",
      "status": "completed",
      "finding": "The review premise was CORRECT - Supabase Auth was in the Auth Provider Compatibility table but NOT listed in the framework-specific wizard options. Supabase Auth is a fully production-ready auth solution with: (1) @supabase/ssr package for Next.js App Router with SSR, middleware, and cookie-based sessions, (2) Official TanStack Start quickstart with supabase-js and @supabase/ssr integration (TanStack Start still in beta), (3) Native React Native/Expo support via @supabase/supabase-js with AsyncStorage for session persistence. Supabase Auth offers the most generous free tier (50,000 MAU vs 10,000 MAU competitors) and Row Level Security (RLS) integration for database-level authorization. It should be offered alongside better-auth and Clerk as a first-class auth option.",
      "action_required": "Updated PLAN.md: Added Supabase Auth to wizard options for all frameworks - Next.js, TanStack Start, React Router v7, Expo (noted native SDK), React Native CLI, and Astro. Supabase Auth now appears as a third auth option alongside better-auth and Clerk in each framework section."
    },
    {
      "id": "review-025",
      "category": "database",
      "task": "Verify Convex compatibility with all frameworks",
      "check": "Convex is listed for Expo backend but is it compatible with Next.js/TanStack?",
      "status": "completed",
      "finding": "Convex is compatible with ALL frameworks mentioned in PLAN.md, not just Expo. Official documentation and integrations exist for: (1) Next.js - full App Router support with server rendering (beta) via convex/nextjs helpers, preloadQuery, fetchQuery, fetchMutation, fetchAction, (2) TanStack Start - first-class integration via @convex-dev/react-query and @tanstack/react-router-with-query with SSR support and live updates, (3) Expo/React Native - uses same convex React client, official quickstart available, (4) Astro - official starter template with withConvexProvider wrapper for React islands. Convex is a hosted backend with reactive database, automatic caching, and realtime useQuery hook. Server-side database queries automatically cache and subscribe to data. Convex Auth (beta) supports both web and React Native. Better Auth integration requires Convex 1.25.0+. The PLAN.md only lists Convex under Expo backend options but it should be added as a backend option for ALL frameworks.",
      "action_required": "Update PLAN.md to add Convex as a backend/database option for Next.js, TanStack Start, React Router v7, and Astro framework sections (not just Expo). Add to Database/Backend Options table. Convex provides real-time sync, reactive queries, and works across all platforms."
    },
    {
      "id": "review-026",
      "category": "database",
      "task": "Verify Firebase option completeness",
      "check": "Firebase is listed but no skills mentioned for it",
      "status": "completed",
      "finding": "Firebase IS listed in PLAN.md as a backend option for Expo (line 116) and in Database/Backend Options table as 'NoSQL / Firebase-like'. However, NO Firebase skill was listed in the Skills by Stack table. Research found: (1) firebase-functions-templates skill EXISTS in community (@onesmartguy/next-level-real-estate) for Cloud Functions with TypeScript/Express, (2) firebase-mcp (gannonh/firebase-mcp) is an MCP server for Firestore/Storage/Auth operations but is NOT a skill, (3) NO comprehensive Firebase skill exists for general Firebase development patterns (Auth, Firestore security rules, real-time listeners). The PLAN.md should add the available Firebase skill to the Skills by Stack table with a note that comprehensive Firebase skills are limited.",
      "action_required": "Update PLAN.md: Add 'Firebase' row to Skills by Stack table with 'firebase-functions-templates' (@onesmartguy/next-level-real-estate) skill. Add note that comprehensive Firebase development skills are limited - consider using firebase-mcp MCP server for Firestore/Auth operations instead."
    },
    {
      "id": "review-027",
      "category": "deployment",
      "task": "Verify EAS auto-selection",
      "check": "Plan auto-selects EAS for Expo - should users have other options?",
      "status": "completed",
      "finding": "YES, users should have other Expo deployment options beyond EAS. Valid alternatives include: (1) Local Builds via `eas build --local` - unlimited free builds using your own Xcode/Android Studio, (2) GitHub Actions + Fastlane - self-hosted CI/CD pipeline that can save $100s monthly vs EAS paid tiers, (3) Codemagic - third-party cloud CI/CD with pay-as-you-go pricing. Auto-selecting EAS ignores cost concerns (free tier limits, paid tiers for production), company policies restricting third-party CI/CD services, teams preferring self-hosted infrastructure, and users wanting faster local iteration. EAS Build should remain the recommended default (easiest, no local setup required) but alternatives should be offered.",
      "action_required": "Updated PLAN.md: (1) Changed Expo deploy line to show all options: 'EAS Build (recommended), Local Builds (eas build --local), GitHub Actions + Fastlane, Codemagic'. (2) Added 'Expo Deployment Options' subsection explaining each option. (3) Updated Mobile Preset to show 'EAS Build (recommended, cloud) or Local Builds'."
    },
    {
      "id": "review-028",
      "category": "deployment",
      "task": "Verify Railway compatibility",
      "check": "Railway is listed for Next.js but not for TanStack Start in detailed section",
      "status": "completed",
      "finding": "The review premise was INCORRECT - Railway IS already listed for TanStack Start in PLAN.md. Line 87 shows 'deploy: Any (Vercel, Cloudflare, Fly.io, Railway)'. Official TanStack Start documentation explicitly lists Railway as a supported deployment target. Railway has multiple community templates for TanStack Start including TanStack Start Monorepo (Bun) with Better Auth + Drizzle + Supabase. TanStack Start uses Nitro with node-server preset that works natively with Railway.",
      "action_required": null
    },
    {
      "id": "review-029",
      "category": "testing",
      "task": "Verify Vitest 4 compatibility",
      "check": "Plan uses vitest ^4.0.0 - is v4 released and stable?",
      "status": "completed",
      "finding": "Vitest 4.0 IS released and production-ready. Released October 22, 2025, with current version v4.0.17 (January 12, 2026). Key features: (1) Browser Mode graduated to stable status, (2) Built-in visual regression testing via toMatchScreenshot, (3) Playwright Traces integration, (4) Enhanced debugging with VSCode extension support, (5) New matchers like expect.schemaMatching and toBeInViewport. Vitest 4 is maintained by VoidZero (same team behind Vite, oxc, Rolldown). Active development with v4.1.0-beta.1 already available. The PLAN.md recommendation of Vitest for web unit testing is correct and v4.x is stable for production use.",
      "action_required": null
    },
    {
      "id": "review-030",
      "category": "testing",
      "task": "Verify Jest + oxlint combination",
      "check": "Does oxlint work well with Jest for React Native projects?",
      "status": "completed",
      "finding": "YES, oxlint works well with Jest for React Native projects. Oxlint 1.0 stable includes a native Jest plugin with 29 Jest-specific rules built in Rust (no-focused-tests, expect-expect, no-disabled-tests, etc.). Enable via --jest-plugin CLI flag or plugins: ['jest'] in .oxlintrc.json. Real-world validation: OneSignal's react-native-onesignal library uses oxlint with Jest. CAVEAT: eslint-plugin-react-native is NOT natively supported in oxlint - it can be used via experimental jsPlugins feature or by running ESLint alongside oxlint (recommended: 'oxlint && eslint') for React Native-specific rules like no-unused-styles, no-inline-styles. The eslint-plugin-oxlint package provides 'flat/jest' config to disable ESLint rules already covered by oxlint.",
      "action_required": null
    },
    {
      "id": "review-031",
      "category": "pre-commit-hooks",
      "task": "Verify prek stability and adoption",
      "check": "Is prek production-ready? Check v0.2.x stability, adoption by Apache Airflow, FastAPI",
      "status": "completed",
      "finding": "prek IS production-ready for most use cases. Current version v0.2.29 (January 2026). Apache Airflow switched to prek in August 2025 (PR #54726 merged) and is now using v0.2.12 in production. FastAPI switched in December 2025 (PR #14572 by tiangolo merged). Supported languages: Python, Node.js, Go, Rust, Ruby, Lua, Docker, System, Script, Pygrep, Fail. NOT supported: Conda, Coursier, Dart, Dotnet, Haskell, Julia, Perl, R, Swift, Deno (experimental). Only missing subcommand is 'gc' (garbage collection). Key advantages: 10x faster than pre-commit, 1/3 disk space, built-in monorepo support, parallel hook execution by priority, uses uv for Python virtualenvs. Fully compatible with existing .pre-commit-config.yaml files.",
      "action_required": null
    },
    {
      "id": "review-032",
      "category": "pre-commit-hooks",
      "task": "Verify prek + bun compatibility",
      "check": "Does prek work well with bun as package manager and runtime?",
      "status": "completed",
      "finding": "Prek does NOT natively support Bun as a package manager or runtime for Node.js hooks. Prek's Node.js language type uses `npm install .` to install hook dependencies - there is no option to use bun instead. However, this is a non-issue for bootstralph because: (1) prek manages its OWN isolated environments for hooks separate from the project's package manager, (2) the project can still use bun as its package manager while prek uses npm for hook environments, (3) prek is installed as a standalone binary (Rust) with no runtime dependencies. The key insight is that prek's hook environments are isolated - they don't interfere with or depend on the project's chosen package manager. Bun support as a hook runtime is not on prek's roadmap (no GitHub issue exists for it).",
      "action_required": "Add clarifying note to PLAN.md Pre-Commit Hook Compatibility section explaining that prek uses npm for Node.js hook environments regardless of project package manager, but this is isolated and doesn't affect project development."
    },
    {
      "id": "review-041",
      "category": "pre-commit-hooks",
      "task": "Verify Lefthook config format for oxlint/oxfmt",
      "check": "Is the Lefthook config syntax correct for oxlint and oxfmt commands?",
      "status": "completed",
      "finding": "The Lefthook configuration syntax for oxlint and oxfmt is straightforward but PLAN.md lacks concrete examples. Verified correct Lefthook YAML syntax: (1) For oxlint: `run: npx oxlint {staged_files}` or `run: npx oxlint --fix {staged_files}` with `stage_fixed: true`, glob patterns like `glob: '*.{js,ts,jsx,tsx}'`. (2) For oxfmt: `run: npx oxfmt {staged_files}` (default behavior writes in place) or `run: npx oxfmt --check {staged_files}` for CI. Key options: `--fix` for oxlint auto-fixes, `--check` for oxfmt CI mode, `stage_fixed: true` to auto-stage fixed files, `{staged_files}` template for pre-commit hooks. Lefthook v1.10.10+ supports multiple glob patterns as a list.",
      "action_required": "Add 'Lefthook Configuration Examples' subsection to PLAN.md showing correct YAML syntax for oxlint and oxfmt pre-commit hooks with glob patterns and stage_fixed option."
    },
    {
      "id": "review-042",
      "category": "pre-commit-hooks",
      "task": "Verify Husky setup for ESM projects",
      "check": "Does Husky work well with ESM-only TypeScript projects?",
      "status": "completed",
      "finding": "YES, Husky 9.x works well with ESM-only TypeScript projects but requires specific configuration. Current version is v9.1.7 (January 2026). Key setup: (1) Use `npx husky init` (not deprecated `husky install`), (2) package.json needs `\"type\": \"module\"` and `\"prepare\": \"husky\"` script, (3) lint-staged supports ESM format in lint-staged.config.js with `export default {}` syntax, (4) .husky/pre-commit file simply contains `npx lint-staged`. CAVEAT: Tools like commitlint may error with 'require() of ES modules is not supported' - workaround is renaming commitlint.config.js to commitlint.config.cjs (CommonJS) or commitlint.config.mjs (ESM). CI environments may need `\"prepare\": \"husky || true\"` to handle missing devDependencies. Husky 9 is an ESM package itself (requires Node.js 18+) and is fully compatible with modern ESM TypeScript projects.",
      "action_required": "Add 'Husky ESM Configuration' subsection to PLAN.md documenting: (1) Required package.json settings for ESM projects, (2) lint-staged.config.js ESM format, (3) commitlint.config.cjs workaround for ESM projects, (4) CI environment considerations."
    },
    {
      "id": "review-033",
      "category": "claude-hooks",
      "task": "Verify Claude Code settings.json format",
      "check": "Is the permissions.deny format correct for Claude Code?",
      "status": "completed",
      "finding": "The permissions.deny format uses Tool(pattern) syntax. Correct syntax: Read(**/.env) for file patterns using gitignore syntax, Bash(command:*) for command patterns (e.g., Bash(sudo:*), Bash(rm:*)), Edit/Write support same gitignore file patterns as Read, WebFetch(domain:example.com) for domain restrictions. CRITICAL ISSUE: Multiple GitHub issues report permissions.deny is NOT being enforced for Read/Write/Edit tools as of late 2025 (issues #6631, #6699, #4467). The workaround is using PreToolUse hooks for reliable enforcement. Settings file locations: ~/.claude/settings.json (user), .claude/settings.json (project, tracked), .claude/settings.local.json (project, not tracked).",
      "action_required": "Add 'Claude Code Settings Configuration' section to PLAN.md documenting: (1) Correct permissions.deny syntax with Tool(pattern) examples for Read, Bash, Edit, Write, WebFetch, (2) Warning about known enforcement issues with deny rules, (3) PreToolUse hook workaround for reliable security enforcement, (4) Settings file hierarchy and locations."
    },
    {
      "id": "review-034",
      "category": "claude-hooks",
      "task": "Verify Ralph plugin installation command",
      "check": "Is '/plugin marketplace add anthropic/ralph-wiggum' the correct command?",
      "status": "completed",
      "finding": "The command '/plugin marketplace add anthropic/ralph-wiggum' is INCORRECT. The correct commands are: (1) Add marketplace: '/plugin marketplace add anthropics/claude-code' (note: 'anthropics' with 's', not 'anthropic'), (2) Install plugin: '/plugin install ralph-wiggum@claude-plugins-official'. The marketplace add command adds a catalog to browse available plugins, not install them. Ralph-wiggum is the official Claude Code plugin for autonomous development loops, maintained by Anthropic. It provides /ralph-loop and /cancel-ralph commands. Usage: /ralph-loop \"task description\" --max-iterations 30 --completion-promise \"DONE\".",
      "action_required": "Add 'Ralph Wiggum Plugin Installation' section to PLAN.md documenting: (1) Correct marketplace add command syntax, (2) Correct plugin install command, (3) Basic usage of /ralph-loop and /cancel-ralph commands."
    },
    {
      "id": "review-035",
      "category": "dependencies",
      "task": "Verify @clack/prompts version",
      "check": "Is ^0.8.0 the latest stable version of @clack/prompts?",
      "status": "completed",
      "finding": "^0.8.0 is OUTDATED. The latest stable version is v0.11.0 (published May 2025, ~2.5M weekly downloads). Key features added since 0.8.0: (1) v0.9.0 - updateSettings() function for global keybindings, signal option for programmatic cancellation with AbortController, (2) v0.10.0 - indicator option for spinner animations (dots/timer modes), stream API for iterable messages, (3) v0.11.0 - taskLog prompt for log output cleared on success, format option for note prompt, customizable spinner cancel/error messages for multilingual CLIs. A v1.0.0 is in alpha (1.0.0-alpha.9) with ESM-only distribution and new APIs, but 0.11.0 remains the latest stable release.",
      "action_required": "Update PLAN.md Tech Stack dependencies from '@clack/prompts: ^0.8.0' to '@clack/prompts: ^0.11.0' to get latest features including programmatic cancellation, taskLog prompt, and multilingual support."
    },
    {
      "id": "review-036",
      "category": "dependencies",
      "task": "Verify execa version",
      "check": "Is ^9.0.0 the correct version? Check for breaking changes",
      "status": "completed",
      "finding": "^9.0.0 IS correct and will resolve to v9.6.1 (latest, January 2026). Execa v9.0.0 was released May 8, 2024 with significant breaking changes from v8.x. Key breaking changes include: (1) Node.js 18.19.0+ required, (2) Buffer output now returns Uint8Array instead of Buffer, (3) encoding option values renamed (null→'buffer', 'utf-8'→'utf8'), (4) pipeStdout/pipeStderr/pipeAll renamed to unified pipe() method, (5) signal option renamed to cancelSignal, (6) error.killed renamed to error.isTerminated, (7) subprocess.cancel() removed (use kill()), (8) verbose option changed from boolean to string enum, (9) execPath renamed to nodePath, (10) execaCommand() deprecated in v9.2.0 (use parseCommandString instead). The package receives 105M+ weekly downloads and is actively maintained.",
      "action_required": "Add dependency version specifications to PLAN.md Tech Stack section including execa: ^9.0.0 and note key breaking changes for migration awareness."
    },
    {
      "id": "review-037",
      "category": "architecture",
      "task": "Verify directory structure completeness",
      "check": "Missing scaffolders for remix.ts, astro.ts, rn-cli.ts",
      "status": "completed",
      "finding": "The PLAN.md directory structure was INCOMPLETE. It only listed 4 scaffolder files (nextjs.ts, tanstack.ts, expo.ts, base.ts) but the Scaffolding Strategy table listed 8 frameworks. Missing files: (1) react-router.ts for React Router v7 (note: Remix merged into React Router v7 per review-012), (2) rn-cli.ts for React Native CLI, (3) astro.ts for Astro, (4) api.ts for Hono/Elysia templates. Updated directory structure to include all 8 scaffolder files. Also updated impl-015 from 'Remix scaffolder' to 'React Router v7 scaffolder' with correct filename react-router.ts.",
      "action_required": null
    },
    {
      "id": "review-038",
      "category": "architecture",
      "task": "Verify presets completeness",
      "check": "Missing presets for content (Astro) and universal (Expo + Tamagui)",
      "status": "pending"
    },
    {
      "id": "review-039",
      "category": "ux",
      "task": "Verify React Native CLI warning is helpful",
      "check": "Warning about Xcode/Android Studio - should we offer to install prerequisites?",
      "status": "pending"
    },
    {
      "id": "review-040",
      "category": "ux",
      "task": "Verify Docker setup instructions clarity",
      "check": "Is the post-scaffold Docker setup flow clear enough for beginners?",
      "status": "pending"
    }
  ],
  "implementation_tasks": [
    {
      "id": "impl-001",
      "phase": 1,
      "task": "Initialize project with bun and TypeScript",
      "files": ["package.json", "tsconfig.json", "tsup.config.ts"],
      "status": "pending"
    },
    {
      "id": "impl-002",
      "phase": 1,
      "task": "Create CLI entry point with @clack/prompts",
      "files": ["src/index.ts"],
      "status": "pending"
    },
    {
      "id": "impl-003",
      "phase": 1,
      "task": "Implement compatibility matrix data structure",
      "files": ["src/compatibility/matrix.ts"],
      "status": "pending"
    },
    {
      "id": "impl-004",
      "phase": 1,
      "task": "Implement option filtering logic",
      "files": ["src/compatibility/filters.ts"],
      "status": "pending"
    },
    {
      "id": "impl-005",
      "phase": 1,
      "task": "Implement combination validators",
      "files": ["src/compatibility/validators.ts"],
      "status": "pending"
    },
    {
      "id": "impl-006",
      "phase": 1,
      "task": "Create project type prompt",
      "files": ["src/prompts/project-type.ts"],
      "status": "pending"
    },
    {
      "id": "impl-007",
      "phase": 1,
      "task": "Create framework selection prompt with filtering",
      "files": ["src/prompts/framework.ts"],
      "status": "pending"
    },
    {
      "id": "impl-008",
      "phase": 1,
      "task": "Create features selection prompt with filtering",
      "files": ["src/prompts/features.ts"],
      "status": "pending"
    },
    {
      "id": "impl-009",
      "phase": 1,
      "task": "Create deployment selection prompt",
      "files": ["src/prompts/deployment.ts"],
      "status": "pending"
    },
    {
      "id": "impl-010",
      "phase": 1,
      "task": "Create tooling selection prompt (recommended vs customize)",
      "files": ["src/prompts/tooling.ts"],
      "status": "pending"
    },
    {
      "id": "impl-011",
      "phase": 1,
      "task": "Implement Next.js scaffolder wrapper",
      "files": ["src/scaffolders/nextjs.ts"],
      "status": "pending"
    },
    {
      "id": "impl-012",
      "phase": 1,
      "task": "Implement TanStack Start scaffolder wrapper",
      "files": ["src/scaffolders/tanstack.ts"],
      "status": "pending"
    },
    {
      "id": "impl-013",
      "phase": 1,
      "task": "Implement Expo scaffolder wrapper",
      "files": ["src/scaffolders/expo.ts"],
      "status": "pending"
    },
    {
      "id": "impl-014",
      "phase": 1,
      "task": "Implement React Native CLI scaffolder wrapper",
      "files": ["src/scaffolders/rn-cli.ts"],
      "status": "pending"
    },
    {
      "id": "impl-015",
      "phase": 1,
      "task": "Implement React Router v7 scaffolder wrapper",
      "files": ["src/scaffolders/react-router.ts"],
      "status": "pending"
    },
    {
      "id": "impl-016",
      "phase": 1,
      "task": "Implement Astro scaffolder wrapper",
      "files": ["src/scaffolders/astro.ts"],
      "status": "pending"
    },
    {
      "id": "impl-017",
      "phase": 1,
      "task": "Implement Hono/Elysia API template",
      "files": ["src/scaffolders/api.ts", "src/templates/api/"],
      "status": "pending"
    },
    {
      "id": "impl-018",
      "phase": 1,
      "task": "Implement create command orchestration",
      "files": ["src/commands/create.ts"],
      "status": "pending"
    },
    {
      "id": "impl-019",
      "phase": 2,
      "task": "Implement CLAUDE.md template generator",
      "files": ["src/ralph/claudemd.ts", "src/templates/CLAUDE.md.ts"],
      "status": "pending"
    },
    {
      "id": "impl-020",
      "phase": 2,
      "task": "Implement skills installation via openskills",
      "files": ["src/ralph/skills.ts"],
      "status": "pending"
    },
    {
      "id": "impl-021",
      "phase": 2,
      "task": "Implement Lefthook configuration generator",
      "files": ["src/ralph/hooks.ts", "src/templates/lefthook.yml.ts"],
      "status": "pending"
    },
    {
      "id": "impl-022",
      "phase": 2,
      "task": "Implement Claude Code hooks setup",
      "files": ["src/templates/.claude/settings.json.ts"],
      "status": "pending"
    },
    {
      "id": "impl-023",
      "phase": 2,
      "task": "Implement Docker sandbox configuration",
      "files": ["src/ralph/sandbox.ts", "src/templates/docker-compose.yml.ts"],
      "status": "pending"
    },
    {
      "id": "impl-024",
      "phase": 2,
      "task": "Implement Ralph setup orchestration",
      "files": ["src/ralph/setup.ts"],
      "status": "pending"
    },
    {
      "id": "impl-025",
      "phase": 3,
      "task": "Implement init command for existing projects",
      "files": ["src/commands/init.ts"],
      "status": "pending"
    },
    {
      "id": "impl-026",
      "phase": 3,
      "task": "Implement add command for post-scaffold features",
      "files": ["src/commands/add.ts"],
      "status": "pending"
    },
    {
      "id": "impl-027",
      "phase": 3,
      "task": "Implement SaaS preset",
      "files": ["src/presets/saas.ts"],
      "status": "pending"
    },
    {
      "id": "impl-028",
      "phase": 3,
      "task": "Implement Mobile preset",
      "files": ["src/presets/mobile.ts"],
      "status": "pending"
    },
    {
      "id": "impl-029",
      "phase": 3,
      "task": "Implement API preset",
      "files": ["src/presets/api.ts"],
      "status": "pending"
    },
    {
      "id": "impl-030",
      "phase": 3,
      "task": "Implement Monorepo preset",
      "files": ["src/presets/fullstack.ts"],
      "status": "pending"
    },
    {
      "id": "impl-031",
      "phase": 4,
      "task": "Write unit tests for compatibility matrix",
      "files": ["tests/compatibility.test.ts"],
      "status": "pending"
    },
    {
      "id": "impl-032",
      "phase": 4,
      "task": "Write unit tests for filtering logic",
      "files": ["tests/filters.test.ts"],
      "status": "pending"
    },
    {
      "id": "impl-033",
      "phase": 4,
      "task": "Write integration tests for scaffolders",
      "files": ["tests/scaffolders.test.ts"],
      "status": "pending"
    },
    {
      "id": "impl-034",
      "phase": 4,
      "task": "Write E2E tests for full wizard flow",
      "files": ["tests/e2e.test.ts"],
      "status": "pending"
    },
    {
      "id": "impl-035",
      "phase": 4,
      "task": "Create README documentation",
      "files": ["README.md"],
      "status": "pending"
    },
    {
      "id": "impl-036",
      "phase": 4,
      "task": "Configure npm publishing",
      "files": ["package.json"],
      "status": "pending"
    }
  ]
}
