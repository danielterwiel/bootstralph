{
  "name": "Pair Vibe Mode",
  "version": "0.1.0",
  "description": "Multi-model Ralph'ing with concurrent review and consensus resolution. When two API keys are detected, users can enable Pair Vibe Mode where one model executes tasks while another reviews steps ahead of time, entering consensus mode when disagreements arise.",
  "status": "planning",
  "branchName": "feature/pair-vibe-mode",
  "mode": "feature",
  "specs": {
    "core_philosophy": {
      "look_ahead_review": "Reviewer works concurrently ahead of Executor, pre-populating findings on future steps",
      "minimal_slowdown": "Only enter Consensus Mode when actual findings exist, otherwise execute at full speed",
      "executor_wins_ties": "When consensus cannot be reached after ultrathink round, Executor's approach wins (they're most invested)",
      "anonymized_review": "Reviewer never sees which model is Executor to prevent sycophancy bias"
    },
    "architecture": {
      "executor_model": "Runs the standard Ralph loop, implementing tasks one at a time",
      "reviewer_model": "Works ahead concurrently, web searching and validating each step before Executor reaches it",
      "consensus_mode": "Triggered when step.findings.length > 0, both models present solutions and attempt to align"
    },
    "failure_modes_addressed": [
      "FM-1.1 Disobey task specification - Reviewer validates against original requirements",
      "FM-2.5 Ignored other agent's input - Consensus mode forces both models to engage",
      "FM-3.2 No or incomplete verification - Reviewer provides independent verification",
      "Sycophancy bias - Anonymized review prevents model identity from influencing judgment"
    ]
  },
  "workflow": {
    "instructions": [
      "Work through review_tasks BEFORE starting implementation_tasks",
      "Update task status to 'in_progress' when starting, 'completed' or 'failed' when done",
      "Add 'finding' field to review tasks with what you discovered",
      "If a review task reveals an issue, add 'action_required' field describing the fix needed",
      "Only proceed to implementation_tasks once all critical review issues are resolved"
    ],
    "status_values": [
      "pending",
      "in_progress",
      "completed",
      "failed",
      "blocked"
    ]
  },
  "review_tasks": [
    {
      "id": "review-001",
      "category": "api-detection",
      "task": "Verify API key detection approach",
      "check": "How should we detect ANTHROPIC_API_KEY and OPENAI_API_KEY? Environment variables only, or also check for config files?",
      "status": "completed",
      "finding": "Environment variables only is the correct approach. Reasons: (1) API keys should never be in config files that might be committed, (2) env vars can be loaded from .env via dotenv/direnv/shell sourcing, (3) this is the standard pattern used by both Anthropic and OpenAI SDKs, (4) existing ralph.sh already does this correctly. For TypeScript impl: use process.env, validate format without API calls (Anthropic: sk-ant-*, OpenAI: sk-* but not sk-ant-)."
    },
    {
      "id": "review-002",
      "category": "web-search",
      "task": "Verify web search implementation options",
      "check": "What's the best approach for Reviewer's web search? Tavily API, SerpAPI, or browser automation? Check cost and rate limits.",
      "status": "completed",
      "finding": "Recommend Tavily API as primary with Brave Search API as fallback. Rationale: (1) Tavily: $0.008/credit, 1-2 credits/search, 100 RPM free tier, 1000 RPM paid, designed specifically for AI agents and RAG applications. (2) Brave: $5/1000 requests (~$0.005/search), 2000 free/month, up to 20 QPS paid tier, privacy-focused independent index. (3) SerpAPI rejected: expensive at $0.015/request ($75/mo for only 5k searches), designed for SEO data extraction not AI grounding. (4) Browser automation rejected: too slow (1-3s per page), requires headless browser infrastructure, anti-bot detection issues, overkill for search synthesis. (5) Perplexity Sonar rejected: more expensive ($1-3/M tokens + $5/1000 searches), designed for conversational search not programmatic. Implementation: Use Tavily's /search endpoint with basic depth (1 credit), cache results by query hash for 15 minutes, fallback to Brave if Tavily rate limited or unavailable."
    },
    {
      "id": "review-003",
      "category": "consensus",
      "task": "Verify ultrathink implementation",
      "check": "How to implement ultrathink? Claude's extended thinking mode requires beta header. OpenAI has no equivalent - use multi-turn reflection instead?",
      "status": "completed",
      "finding": "Use native extended thinking for Claude, reasoning_effort for OpenAI o-series, and multi-turn reflection fallback for GPT-4. Implementation details: (1) CLAUDE: Use 'thinking' object with {type: 'enabled', budget_tokens: 10000}. Minimum budget 1024 tokens. Supported models: Claude 4 Opus/Sonnet, Claude 3.7 Sonnet. For interleaved thinking add beta header 'interleaved-thinking-2025-05-14'. Response includes 'thinking' content blocks with reasoning chain. Constraints: incompatible with temperature/top_p/top_k modifications, budget_tokens must be < max_tokens unless using interleaved thinking. (2) OPENAI O-SERIES (o1, o3, o3-mini): Use 'reasoning_effort' parameter with values 'low'/'medium'/'high'. Default is 'medium'. High improves accuracy 10-30% but costs more. Chain of thought is hidden (summarized only). Use Responses API for best performance. (3) GPT-4 FALLBACK: Multi-turn reflection pattern - Turn 1: generate initial proposal, Turn 2: critique own proposal (prompt: 'Review your proposal for flaws, edge cases, and improvements'), Turn 3: refine based on critique. This provides similar depth without native thinking support. (4) RECOMMENDATION: Abstract behind UltrathinkProvider interface that detects model type and applies appropriate strategy. Return normalized response with reasoning_summary (visible thinking/summary) and final_proposal fields."
    },
    {
      "id": "review-004",
      "category": "parallelism",
      "task": "Verify concurrent execution safety",
      "check": "When Reviewer and Executor run concurrently, how do we handle PRD file locking to prevent race conditions?",
      "status": "completed",
      "finding": "Use a two-layer locking strategy: (1) IN-PROCESS: Use async-lock for within-process serialization of PRD writes. This handles the common case where both Reviewer and Executor are async tasks in the same Node process. Create a shared AsyncLock instance with key based on PRD file path. Wrap all PrdManager.save() calls with lock.acquire(). (2) CROSS-PROCESS: Use proper-lockfile for file-based locking if supporting multiple processes (not needed for initial impl). The mkdir-based strategy is atomic on NFS. (3) ATOMIC WRITES: Use write-file-atomic (already battle-tested in npm ecosystem) to ensure partial writes don't corrupt the PRD. Write to temp file, then rename. (4) EXISTING CODE: PrdManager.save() at line 133 uses direct writeFile - wrap with async-lock. The scheduleSave() debounce at line 155 already helps reduce contention but doesn't prevent it. RECOMMENDATION: Add async-lock as dependency. Create src/ralph/prd-lock.ts with a singleton lock per PRD path. Modify PrdManager to acquire lock before save. Timeout: 5 seconds. Retries: 3 with exponential backoff (100ms, 200ms, 400ms). If lock fails, log warning and queue retry - never lose data."
    },
    {
      "id": "review-005",
      "category": "rate-limits",
      "task": "Verify rate limit handling",
      "check": "What rate limits apply when using both Claude and OpenAI simultaneously? How do we implement exponential backoff with jitter?",
      "status": "completed",
      "finding": "Both providers use tier-based rate limits with RPM, TPM (input/output). Claude Tier 1-4: RPM 50-4000, ITPM 30K-2M, OTPM 8K-400K for Sonnet/Opus. OpenAI Tier 1: ~500 RPM, 30K TPM for GPT-4o (varies by tier). IMPLEMENTATION: (1) Use 'Full Jitter' exponential backoff per AWS best practice: sleep = random(0, min(cap, base * 2^attempt)). Base: 1s, Cap: 60s, Max attempts: 6. (2) Respect 'retry-after' header from 429 responses - both APIs provide this. (3) Claude provides detailed headers: anthropic-ratelimit-{requests,tokens,input-tokens,output-tokens}-{limit,remaining,reset}. OpenAI provides: x-ratelimit-{limit,remaining,reset}-{requests,tokens}. (4) Track limits PER PROVIDER independently since Reviewer (OpenAI) and Executor (Claude) have separate quotas. (5) Use token bucket algorithm client-side to proactively avoid hitting limits. (6) On repeated failures (3+ retries exhausted): emit 'rate-limit-degraded' event, warn user, continue with single-model mode if one provider still available. (7) Cache-aware: Claude's ITPM only counts uncached input tokens - leverage prompt caching for 5-10x effective throughput. CIRCUIT BREAKER: After 5 consecutive 429s from same provider within 60s, open circuit for 2 minutes before retrying."
    },
    {
      "id": "review-006",
      "category": "sycophancy",
      "task": "Research sycophancy mitigation",
      "check": "The CONSENSAGENT paper proposes dynamic prompt refinement. Should we implement their approach or use simpler anonymization?",
      "status": "completed",
      "finding": "Recommend SIMPLER ANONYMIZATION over CONSENSAGENT's dynamic prompt refinement. Rationale: (1) ANONYMIZATION APPROACH: Remove identity markers from consensus prompts so agents cannot distinguish 'self' from 'peer'. Present proposals as 'Proposal A' and 'Proposal B' without attribution. Research shows this dramatically reduces identity bias (e.g., Qwen-32B IBC dropped from 0.608 to 0.024). Requires no model retraining or architectural changes. (2) CONSENSAGENT APPROACH: Dynamic prompt refinement based on agent interactions. More complex to implement, requires tracking interaction patterns and adjusting prompts accordingly. Achieves SOTA on benchmark datasets but adds significant complexity. (3) RECOMMENDATION FOR PAIR VIBE: Use anonymization as primary strategy - it's simpler, effective, and directly addresses our edge-006 case. Implementation: During consensus, label proposals as 'Proposal A/B' not 'Claude/OpenAI', require explicit reasoning for agreement (flag suspiciously quick consensus), and use Identity Bias Coefficient (IBC = conformity_rate_vanilla - conformity_rate_anonymized) as diagnostic metric. (4) ADDITIONAL SAFEGUARDS: Require minimum reasoning length in consensus responses, detect verbatim copying between proposals, log consensus duration (flag if < 30 seconds). (5) FUTURE ENHANCEMENT: Consider CONSENSAGENT's dynamic refinement if anonymization proves insufficient, but start simple."
    },
    {
      "id": "review-007",
      "category": "timeouts",
      "task": "Verify timeout strategy",
      "check": "What happens if Reviewer is stuck on web search when Executor needs to proceed? Define timeout thresholds and fallback behavior.",
      "status": "completed",
      "finding": "Implement a THREE-TIER TIMEOUT STRATEGY with circuit breaker pattern. TIER 1 - WEB SEARCH (30s): Individual Tavily/Brave API calls timeout at 30s. After 2 consecutive failures, circuit opens for 60s, returning cached/empty results. TIER 2 - REVIEW STEP (2min): Total time for Reviewer to complete one step review (search + analysis). If exceeded, mark step as 'review_timeout' and let Executor proceed without review. Log warning. TIER 3 - REVIEWER LAG (5 steps): If Executor is 5+ steps ahead of Reviewer, pause Executor with 'Waiting for review...' status. After 2min wait timeout, warn and continue without review for that step. STREAMING: Use streaming for all LLM calls with 90s idle timeout (no data received). Anthropic recommends streaming for requests >10min. CIRCUIT BREAKER: Three states (closed/open/half-open). Failure threshold: 3, Reset timeout: 60s. Half-open allows 1 test request. Use opossum library for Node.js. IMPLEMENTATION: Create TimeoutManager class with per-operation timeouts. Emit events: 'review-timeout', 'search-timeout', 'circuit-open', 'circuit-half-open'. Graceful degradation: continue with single-model execution if Reviewer consistently times out. Existing codebase uses 10min iteration timeout (engine.ts:59) - maintain this for Executor. FALLBACK CHAIN: 1) Retry with backoff, 2) Skip web search (use LLM knowledge only), 3) Skip review for step, 4) Degrade to single-model mode."
    },
    {
      "id": "review-008",
      "category": "cost",
      "task": "Estimate cost multiplier",
      "check": "Pair Vibe Mode will increase API costs. Calculate expected multiplier and add cost warning to UI.",
      "status": "completed",
      "finding": "EXPECTED COST MULTIPLIER: 2.2-3.5x depending on consensus frequency. BREAKDOWN: (1) BASE MODEL COSTS - Claude Sonnet 4.5: $3/M input, $15/M output. OpenAI GPT-4o: $2.50/M input, $10/M output. GPT-4.1: $2/M input, $8/M output. OpenAI o3: $2/M input, $8/M output. (2) PAIR VIBE COMPONENTS - Executor: 1.0x baseline (unchanged). Reviewer: +0.6x (runs ahead, fewer output tokens ~40% of Executor since primarily analysis not code generation). Web Search: +$0.008-0.016/step via Tavily (negligible, ~1-2 searches per step at $0.008/credit). (3) CONSENSUS MODE OVERHEAD - When triggered (~20-40% of steps based on research): Both models propose (+0.5x), Ultrathink round if needed (+1.5-3x for that step due to extended thinking/reasoning_effort), Average 1.5 rounds per consensus. (4) COST SCENARIOS - Low friction (10% consensus rate): 2.2x multiplier. Medium friction (25% consensus rate): 2.8x multiplier. High friction (40% consensus rate): 3.5x multiplier. (5) COST OPTIMIZATION STRATEGIES - Use GPT-4.1 or o3 ($2/M input) as Reviewer instead of GPT-4o ($2.50/M). Use Claude prompt caching (90% discount on cached input). Use Batch API for non-urgent consensus (50% discount). Skip web search for well-understood technologies. (6) UI WARNING TEXT: 'Pair Vibe Mode runs two models concurrently with independent review. Expected cost: 2-4x single model. Actual cost depends on how often consensus is needed. Proceed?' (7) REAL-TIME COST DISPLAY: Show running cost estimate in StatusBar with breakdown by model and phase."
    }
  ],
  "implementation_tasks": [
    {
      "id": "impl-001",
      "phase": 1,
      "task": "Create API key detector utility",
      "files": ["src/ralph/api-keys.ts"],
      "status": "completed",
      "description": "Detect available API keys (ANTHROPIC_API_KEY, OPENAI_API_KEY) from environment. Return object with available providers and validation status. Check key format validity without making API calls.",
      "completedAt": "2026-01-18T12:59:30.000Z",
      "notes": "Implemented detectApiKeys(), validateApiKey(), hasValidApiKey(), getAvailableProviders(), canEnablePairVibeMode() functions. Validates Anthropic (sk-ant-*) and OpenAI (sk-* but not sk-ant-*) key formats. All types exported for use in pair-vibe-types.ts."
    },
    {
      "id": "impl-002",
      "phase": 1,
      "task": "Extend UserStory type with review fields",
      "files": ["src/ralph/prd-schema.ts"],
      "status": "completed",
      "description": "Add new fields: findings (string[] | null), consensus ({ executorProposal, reviewerProposal, aligned, finalDecision, decidedBy, rounds, timestamp }). Update JSON schema. Ensure backwards compatibility with existing PRDs.",
      "completedAt": "2026-01-18T13:01:30.000Z",
      "notes": "Added ConsensusRecord interface with executorProposal, reviewerProposal, aligned, finalDecision, decidedBy, rounds, timestamp, status, and notes fields. Extended UserStory with optional findings (string[] | null) and consensus (ConsensusRecord | null) fields. Updated PRD_JSON_SCHEMA with full validation for new fields. Backwards compatible - all new fields are optional."
    },
    {
      "id": "impl-003",
      "phase": 1,
      "task": "Create Pair Vibe Mode configuration types",
      "files": ["src/ralph/pair-vibe-types.ts"],
      "status": "completed",
      "description": "Define interfaces: PairVibeConfig (enabled, executorProvider, reviewerProvider, executorModel, reviewerModel), PairVibeState (currentPhase: 'review' | 'execute' | 'consensus', reviewerProgress, executorProgress), ConsensusResult.",
      "completedAt": "2026-01-18T13:04:00.000Z",
      "notes": "Created comprehensive type definitions for Pair Vibe Mode: PairVibeConfig (with defaults), PairVibeState, PairVibePhase, StepProgress, ConsensusSession, ConsensusProposal, ConsensusResult, PairVibeEvent (discriminated union for all events), CostBreakdown, PairVibeMetrics, StepMetrics. Added helper functions: createInitialPairVibeState(), createStepProgress(), createDefaultPairVibeConfig(), checkSycophancyRisk(). Includes model type definitions for Claude and OpenAI."
    },
    {
      "id": "impl-004",
      "phase": 1,
      "task": "Create web search service for Reviewer",
      "files": ["src/ralph/web-search.ts"],
      "status": "completed",
      "description": "Implement WebSearchService class that searches for: best practices for technology, known issues with specific versions, alternative approaches. Support Tavily API (primary) with fallback to Brave Search API. Include caching to avoid duplicate searches. Env vars: TAVILY_API_KEY, BRAVE_SEARCH_API_KEY.",
      "completedAt": "2026-01-18T13:06:30.000Z",
      "notes": "Implemented WebSearchService class with Tavily API (primary) and Brave Search API (fallback). Features: 15-minute cache with query hash keys, configurable timeouts (30s default per review-007), search depth options (basic/advanced), domain filtering. Includes searchQueries helper functions for common Reviewer use cases (bestPractices, knownIssues, alternatives, security, performance). Emits PairVibeEvent for search lifecycle (started/completed/failed). All types properly exported."
    },
    {
      "id": "impl-005",
      "phase": 2,
      "task": "Implement ReviewerRunner class",
      "files": ["src/ralph/reviewer-runner.ts"],
      "status": "completed",
      "description": "Class that runs ahead of Executor, reviewing future steps. For each unreviewed step: 1) Web search for potential issues, 2) Analyze step against search results, 3) Set step.findings = [] (clean) or [...] (issues). Emit events for UI updates. Handle cancellation when consensus needed.",
      "completedAt": "2026-01-18T13:10:00.000Z",
      "notes": "Implemented ReviewerRunner class with concurrent step review. Features: (1) Runs ahead of Executor by configurable MAX_STEPS_AHEAD (5). (2) Web search using WebSearchService with auto-generated queries based on step content. (3) Technology detection (React, Vue, TypeScript, databases, etc.) for smart query generation. (4) LLM client abstraction for provider-agnostic analysis. (5) Timeout handling per review-007: 30s per search, 2min per step review. (6) Pause/resume/stop controls for consensus mode. (7) PairVibeEvent emission for UI integration. (8) Heuristic findings extraction when LLM unavailable. All types exported for use by PairVibeEngine."
    },
    {
      "id": "impl-006",
      "phase": 2,
      "task": "Implement ConsensusRunner class",
      "files": ["src/ralph/consensus-runner.ts"],
      "status": "completed",
      "description": "Orchestrate consensus resolution when findings exist. Round 1: Both models present proposals (anonymized). Check alignment. Round 2 (if needed): Ultrathink mode with web search. Round 3 (if still misaligned): Executor wins. Record decision in step.consensus field. Max timeout: 5 minutes.",
      "completedAt": "2026-01-18T13:14:00.000Z",
      "notes": "Implemented ConsensusRunner class with full spec compliance. Features: (1) Multi-round consensus (default 2 rounds before executor wins per edge-003). (2) Anonymized proposals as A/B to prevent sycophancy per edge-006. (3) Ultrathink mode triggers on round 2+ with optional web search grounding. (4) 5-minute timeout with graceful handling per impl-006. (5) Sycophancy risk detection via checkSycophancyRisk(). (6) ConsensusLLMClient interface for provider-agnostic proposal generation and alignment checking. (7) toConsensusRecord() for PRD storage. (8) Event emission for UI integration. (9) Cancel support per edge-007 for saving partial state. All types exported."
    },
    {
      "id": "impl-007",
      "phase": 2,
      "task": "Implement ultrathink prompting",
      "files": ["src/ralph/ultrathink.ts"],
      "status": "completed",
      "description": "Create ultrathink prompt wrapper. For Claude: Use extended thinking mode with beta header. For OpenAI: Use multi-turn reflection (generate -> critique -> refine). Both: Include structured web search results. Return enhanced proposal with reasoning chain.",
      "completedAt": "2026-01-18T13:18:00.000Z",
      "notes": "Implemented ultrathink module with provider-agnostic UltrathinkProvider interface. Features: (1) ClaudeUltrathinkProvider: Uses extended thinking with 'thinking' object, budget_tokens (min 1024, default 10000), and beta header 'interleaved-thinking-2025-05-14' per review-003. (2) OpenAIOSeriesUltrathinkProvider: Uses reasoning_effort parameter ('low'/'medium'/'high') for o1/o3/o3-mini models. (3) GPT4ReflectionProvider: Multi-turn reflection fallback (generate → critique → refine) for gpt-4o/gpt-4.1. (4) Factory function createUltrathinkProvider() auto-selects provider based on model. (5) Normalized UltrathinkResult with finalProposal, reasoningSummary, metadata, tokenUsage. (6) Helper functions: isClaudeModel(), isOpenAIOSeriesModel(), isGPTModel(), supportsExtendedThinking(), getRecommendedThinkingBudget(), getRecommendedReasoningEffort(). All exports typed and compatible with ConsensusRunner integration."
    },
    {
      "id": "impl-008",
      "phase": 2,
      "task": "Implement PairVibeEngine orchestrator",
      "files": ["src/ralph/pair-vibe-engine.ts"],
      "status": "completed",
      "description": "Main orchestrator class. Spawn Reviewer as concurrent async task. Main loop: check if next step has findings !== null, if findings.length > 0 enter consensus, otherwise execute. Handle pause/resume. Emit structured events for TUI. Graceful shutdown on errors.",
      "completedAt": "2026-01-18T13:24:00.000Z",
      "notes": "Implemented PairVibeEngine class with full spec compliance. Features: (1) Concurrent Reviewer loop via runReviewerLoop() with configurable maxLookAhead. (2) Main Executor loop via runExecutorLoop() that checks for findings and enters consensus when needed. (3) Pause/resume/stop controls with graceful state management. (4) PairVibeEvent emission for TUI integration. (5) Metrics tracking via PairVibeMetrics and StepMetrics. (6) Edge case handling: edge-001 (wait for review timeout), edge-008 (cap concurrent consensus at 1), edge-009 (proceed without review). (7) External adapters for executeStep and savePrd. (8) Component access via getReviewerRunner(), getConsensusRunner(), getWebSearchService(). All types properly exported."
    },
    {
      "id": "impl-009",
      "phase": 3,
      "task": "Add Pair Vibe Mode prompt to ralph command",
      "files": ["src/commands/ralph.ts"],
      "status": "completed",
      "description": "When starting ralph: 1) Detect available API keys, 2) If 2+ keys found, prompt 'Enable Pair Vibe Mode?', 3) If yes, prompt for Executor/Reviewer assignment, 4) Show cost warning, 5) Start PairVibeEngine instead of single runner.",
      "completedAt": "2026-01-18T13:38:00.000Z",
      "notes": "Added Pair Vibe Mode integration to ralph command. Features: (1) CLI args: --pair-vibe, --no-pair-vibe, --executor <provider>, --reviewer <provider>. (2) API key detection via detectApiKeys() from api-keys.ts. (3) Interactive prompts: enable confirmation, executor assignment, cost warning with breakdown (2-4x multiplier estimates). (4) runPairVibeTuiMode() function that creates PairVibeEngine and forwards all events to TUI with appropriate log sources (reviewer/executor/consensus/search). (5) Model display names for user-friendly output. (6) Graceful shutdown on SIGINT/SIGTERM. Type check: PASSED."
    },
    {
      "id": "impl-010",
      "phase": 3,
      "task": "Add Pair Vibe status to TUI StatusBar",
      "files": ["src/tui/components/StatusBar.tsx"],
      "status": "completed",
      "description": "Extend StatusBar to show: [PAIR VIBE] indicator when active, Reviewer progress (X steps ahead), Current phase (review/execute/consensus), Consensus round indicator when in consensus mode.",
      "completedAt": "2026-01-18T13:38:00.000Z",
      "notes": "Added Pair Vibe Mode indicators to StatusBar component. Features: (1) Added PairVibeStatus interface and signals to store (pairVibeStatus, isPairVibeActive, pairVibePhaseText). (2) Store actions: enablePairVibe(), disablePairVibe(), updatePairVibePhase(), updateReviewerProgress(), updateExecutorProgress(), setActiveConsensus(). (3) StatusBar displays: [PAIR VIBE] indicator in magenta, phase indicator with color-coding (purple=REVIEW, blue=EXEC, orange=CONSENSUS, etc.), Reviewer ahead count, consensus round indicator. (4) CompactStatusBar also updated with Pair Vibe info. (5) Added 21 tests for new store functionality and helper functions. Type check: PASSED. Tests: 693 PASSED."
    },
    {
      "id": "impl-011",
      "phase": 3,
      "task": "Add Pair Vibe log formatting to LogPane",
      "files": ["src/tui/components/LogPane.tsx"],
      "status": "completed",
      "description": "Color-code logs by source: Executor (blue), Reviewer (purple), Consensus (yellow), System (gray). Add collapsible sections for consensus discussions. Show web search results in dimmed text.",
      "completedAt": "2026-01-18T13:44:00.000Z",
      "notes": "Implemented Pair Vibe Mode log formatting in LogPane component. Features: (1) Source-based coloring: Executor/Claude (blue #55aaff), Reviewer/OpenAI (purple #bb88ff), Consensus (orange #ffaa55), Search (dimmed #666666), System (gray #888888). (2) Source prefixes: [EXE], [REV], [CON], [SRC], [SYS] for Pair Vibe Mode. (3) Collapsible consensus sections with groupLogsWithConsensus() that detects start/end markers and groups entries. (4) ConsensusSection component with expand/collapse toggle and summary (Consensus reached/timeout/Executor decision). (5) isPairVibeActive integration to switch between normal and Pair Vibe rendering modes. Added 36 new tests covering getSourceColor, isPairVibeSource, getSourcePrefix, isConsensusStart, isConsensusEnd, and groupLogsWithConsensus. Type check: PASSED. Tests: 729/729 PASSED."
    },
    {
      "id": "impl-012",
      "phase": 3,
      "task": "Implement /consensus command",
      "files": ["src/tui/commands/consensus.ts"],
      "status": "completed",
      "description": "New slash command to manually trigger consensus mode for current step. Useful when user notices an issue before Reviewer does. Syntax: /consensus 'reason for concern'. Pauses execution and enters consensus.",
      "completedAt": "2026-01-18T13:50:00.000Z",
      "notes": "Implemented /consensus command for Pair Vibe Mode. Features: (1) Added 'consensus' to CommandName type in types.ts with ConsensusCommandArgs interface. (2) Added command definition in parser.ts with category 'control', requires min 1 arg for reason. (3) Created consensus.ts with executeConsensusCommand(), handleConsensusCommand(), triggerConsensus(), canTriggerConsensus(), getConsensusHelp(). (4) Validates Pair Vibe Mode is active and engine is running. (5) Calls engine.triggerConsensus(reason) which adds finding to current step. (6) Added store.registerPairVibeEngine() and store.getPairVibeEngine() for engine access. (7) Registered engine with store in ralph.ts runPairVibeTuiMode(). (8) Added command handler to TUI switch in handleTuiCommand(). (9) Updated tests for 11 commands. Type check: PASSED. Tests: 729/729 PASSED."
    },
    {
      "id": "impl-013",
      "phase": 3,
      "task": "Implement /reviewer command",
      "files": ["src/tui/commands/reviewer.ts"],
      "status": "completed",
      "description": "Commands to control Reviewer: /reviewer status (show progress), /reviewer pause (pause look-ahead), /reviewer resume, /reviewer skip <step-id> (skip reviewing a step). Useful when Reviewer is slow or stuck.",
      "completedAt": "2026-01-18T13:58:00.000Z",
      "notes": "Implemented /reviewer command with 4 subcommands: status (shows state, current step, reviewed count), pause (pauses look-ahead review), resume (resumes review), skip <step-id> (skips reviewing a step). Added to CommandName type, parser, and ralph.ts command handler. Integrated with store.getPairVibeEngine().getReviewerRunner(). Updated tests for 12 commands. Type check: PASSED. Tests: 729/729 PASSED."
    },
    {
      "id": "impl-014",
      "phase": 4,
      "task": "Update ralph.sh for Pair Vibe Mode",
      "files": ["ralph.sh"],
      "status": "completed",
      "description": "Add --pair-vibe flag to ralph.sh. Detect API keys from environment. If flag set and 2 keys available, prompt for model assignment (or accept --executor=claude --reviewer=openai args). Pass config to bootstralph ralph.",
      "completedAt": "2026-01-18T14:02:00.000Z",
      "notes": "Added Pair Vibe Mode flags (--pair-vibe, --no-pair-vibe, --executor, --reviewer) to ralph.sh. Features: (1) API key detection via can_enable_pair_vibe(). (2) Interactive prompts: executor/reviewer assignment with provider selection, cost warning with 2-4x multiplier estimate. (3) Validation: ensures executor and reviewer are different providers, auto-infers missing role from the other. (4) get_pair_vibe_flags() passes config to docker sandbox run claude. (5) Status display in AFK and interactive modes. (6) Help text updated with Pair Vibe Mode options. Bash syntax check: PASSED. Type check: PASSED. Tests: 729/729 PASSED."
    },
    {
      "id": "impl-015",
      "phase": 4,
      "task": "Update afk-ralph.sh for Pair Vibe Mode",
      "files": ["afk-ralph.sh"],
      "status": "pending",
      "description": "Add --pair-vibe flag with defaults for unattended mode. Default: Claude as Executor (more capable), OpenAI as Reviewer (faster for search synthesis). Add --no-pair-vibe to force single model even when both keys exist."
    },
    {
      "id": "impl-016",
      "phase": 4,
      "task": "Implement rate limit handler with backoff",
      "files": ["src/ralph/rate-limiter.ts"],
      "status": "pending",
      "description": "Create RateLimiter class with: exponential backoff with jitter, per-provider rate tracking, Retry-After header respect, circuit breaker for repeated failures, graceful degradation (warn and continue with single model if one provider fails)."
    },
    {
      "id": "impl-017",
      "phase": 4,
      "task": "Implement PRD file locking",
      "files": ["src/ralph/prd-lock.ts"],
      "status": "pending",
      "description": "Prevent race conditions when Reviewer and Executor both update PRD. Use proper-lockfile or similar. Lock before write, unlock after. Timeout: 5 seconds. On conflict: retry 3 times with backoff."
    },
    {
      "id": "impl-018",
      "phase": 5,
      "task": "Add Pair Vibe metrics and logging",
      "files": ["src/ralph/pair-vibe-metrics.ts"],
      "status": "pending",
      "description": "Track: consensus rounds per step, reviewer ahead distance, findings per step, time in each phase, cost per model. Write to .agents/metrics/pair-vibe-{timestamp}.json. Display summary at end of ralph session."
    },
    {
      "id": "impl-019",
      "phase": 5,
      "task": "Add cost estimation and warning",
      "files": ["src/ralph/cost-estimator.ts"],
      "status": "pending",
      "description": "Estimate cost multiplier for Pair Vibe Mode based on: task count, expected consensus rate, model pricing. Show warning before starting: 'Pair Vibe Mode may cost 2-4x more than single model. Continue?'"
    },
    {
      "id": "impl-020",
      "phase": 5,
      "task": "Write unit tests for ReviewerRunner",
      "files": ["tests/ralph/reviewer-runner.test.ts"],
      "status": "pending",
      "description": "Test: look-ahead execution, findings population, cancellation on consensus, web search mocking, timeout handling, error recovery."
    },
    {
      "id": "impl-021",
      "phase": 5,
      "task": "Write unit tests for ConsensusRunner",
      "files": ["tests/ralph/consensus-runner.test.ts"],
      "status": "pending",
      "description": "Test: alignment detection, multi-round escalation, executor-wins tiebreaker, anonymization, timeout handling, decision recording."
    },
    {
      "id": "impl-022",
      "phase": 5,
      "task": "Write unit tests for PairVibeEngine",
      "files": ["tests/ralph/pair-vibe-engine.test.ts"],
      "status": "pending",
      "description": "Test: concurrent execution, pause/resume, graceful shutdown, event emission, phase transitions, edge cases (empty PRD, all steps have findings, etc.)."
    },
    {
      "id": "impl-023",
      "phase": 5,
      "task": "Write integration tests for full Pair Vibe flow",
      "files": ["tests/ralph/pair-vibe-integration.test.ts"],
      "status": "pending",
      "description": "End-to-end tests with mocked API calls. Test: happy path, consensus triggered, reviewer faster than executor, executor faster than reviewer, rate limit recovery, single model fallback."
    },
    {
      "id": "impl-024",
      "phase": 6,
      "task": "Update README with Pair Vibe Mode documentation",
      "files": ["README.md"],
      "status": "pending",
      "description": "Add section: What is Pair Vibe Mode, how to enable, model assignment recommendations, cost implications, CLI flags, troubleshooting."
    },
    {
      "id": "impl-025",
      "phase": 6,
      "task": "Create Pair Vibe Mode architecture diagram",
      "files": ["docs/pair-vibe-architecture.md"],
      "status": "pending",
      "description": "Create ASCII/Mermaid diagram showing: Executor loop, Reviewer concurrent track, consensus mode trigger, phase transitions, data flow between components."
    }
  ],
  "edge_cases": {
    "description": "Critical edge cases identified from research on multi-agent LLM system failures (MAST framework)",
    "cases": [
      {
        "id": "edge-001",
        "scenario": "Reviewer is slower than Executor",
        "handling": "Executor waits at step where findings === null. Show 'Waiting for review...' in status. Timeout after 2 minutes, then warn and proceed without review for that step.",
        "failure_mode_addressed": "FM-1.5 Unaware of termination conditions"
      },
      {
        "id": "edge-002",
        "scenario": "Reviewer and Executor both update PRD simultaneously",
        "handling": "Use file locking (proper-lockfile). If lock cannot be acquired after 5s and 3 retries, queue the write and retry. Never lose data.",
        "failure_mode_addressed": "Resource contention / deadlock"
      },
      {
        "id": "edge-003",
        "scenario": "Consensus cannot be reached after 2 rounds",
        "handling": "Executor wins by default. Log decision rationale. Add note to step: 'Consensus not reached, proceeded with Executor approach.'",
        "failure_mode_addressed": "FM-2.4 Information withholding"
      },
      {
        "id": "edge-004",
        "scenario": "One API provider hits rate limit",
        "handling": "Exponential backoff with jitter (base: 1s, max: 60s, 6 retries). If still failing, warn user and fall back to single-model mode.",
        "failure_mode_addressed": "Infrastructure failure / graceful degradation"
      },
      {
        "id": "edge-005",
        "scenario": "Reviewer's web search returns no results",
        "handling": "Set findings = [] (clean) with note 'No external validation available'. Proceed without blocking Executor.",
        "failure_mode_addressed": "FM-3.2 No or incomplete verification"
      },
      {
        "id": "edge-006",
        "scenario": "Sycophancy: Models agree too readily",
        "handling": "Anonymize model responses during comparison (call them 'Proposal A' and 'Proposal B'). Require explicit reasoning for agreement. Flag suspiciously short consensus rounds.",
        "failure_mode_addressed": "Sycophancy bias (CONSENSAGENT)"
      },
      {
        "id": "edge-007",
        "scenario": "User cancels during consensus mode",
        "handling": "Save partial consensus state to step.consensus with status: 'cancelled'. Next run can resume or restart consensus.",
        "failure_mode_addressed": "FM-2.1 Conversation reset"
      },
      {
        "id": "edge-008",
        "scenario": "All steps have findings (pathological case)",
        "handling": "Cap concurrent consensus at 1 to avoid overwhelming both models. Queue remaining consensus. Show progress: 'Resolving consensus 3/10'.",
        "failure_mode_addressed": "Resource exhaustion"
      },
      {
        "id": "edge-009",
        "scenario": "Executor completes step but Reviewer hasn't reviewed it yet",
        "handling": "Mark step as 'passed_without_review'. Log warning. Continue to next step. Reviewer catches up asynchronously for future steps.",
        "failure_mode_addressed": "FM-3.1 Premature termination"
      },
      {
        "id": "edge-010",
        "scenario": "Context window overflow during consensus",
        "handling": "Truncate earlier conversation rounds, keep: original step, findings summary, latest proposals. Use summarization if needed.",
        "failure_mode_addressed": "FM-1.4 Loss of conversation history"
      }
    ]
  },
  "plugins": {
    "recommended": [
      "webapp-testing",
      "test-driven-development",
      "systematic-debugging"
    ],
    "optional": [
      "verification-before-completion"
    ]
  },
  "metadata": {
    "createdAt": "2026-01-18T00:00:00.000Z",
    "createdBy": "bootstralph-prd-writer",
    "completionPromise": "<promise>COMPLETE</promise>",
    "research_sources": [
      "https://github.com/karpathy/llm-council",
      "https://arxiv.org/abs/2503.13657",
      "https://aclanthology.org/2025.findings-acl.1141/",
      "https://arxiv.org/abs/2510.04371",
      "https://arxiv.org/abs/2510.07517"
    ]
  }
}
